# -*-Python-*-

##
## SCons script for building HAsim dictionaries
##

import os
import re
import string
import sys

defs = {
    'BSC'                : '@BSC@',
    'BSC_FLAGS'          : '@BSC_FLAGS@',
    'DICT_SRCS'          : '@DICT_SRCS@',
    'RRR_SRCS'           : '@RRR_SRCS@',
    'TMP_BSC_DIR'        : '@TMP_BSC_DIR@',
}

# Propagate environment from external state
env = Environment(ENV = os.environ, DEFS = defs)
env['ENV']['SHELL'] = '/bin/sh'

BSC = env['DEFS']['BSC']
BSC_FLAGS = env['DEFS']['BSC_FLAGS']
TMP_BSC_DIR = env['DEFS']['TMP_BSC_DIR']

dict_inc_tgt = 'build/include/asim/dict/'
rrr_inc_tgt = 'build/include/asim/rrr/'
hw_tgt = 'build/hw'

if env.GetOption('clean'):
    os.system('rm -rf build')
else:
    if not os.path.isdir(dict_inc_tgt):
        os.makedirs(dict_inc_tgt)
    if not os.path.isdir(rrr_inc_tgt):
        os.makedirs(rrr_inc_tgt)
    if not os.path.isdir(hw_tgt):
        os.makedirs(hw_tgt + '/' + TMP_BSC_DIR)

tgt = []

# Compile dictionary
#  NOTE: this must run even if there are no dictionary files.  It always
#  builds an init.h, even if it is empty.  That way any model can safely
#  include init.h in a standard place.

# First define an emitter that describes all the files generated by dictionaries
all_gen_bsv = []
def dict_emitter(target, source, env):
    global all_gen_bsv
    # Output file names are a function of the contents of dictionary files,
    # not the names of dictionary files.
    src_names = ''
    for s in source:
        src_names += ' ' + str(s)
    # Ask hasim-dict for the output names based on the input files
    for d in os.popen('hasim-dict --querymodules' + src_names).readlines():
        d = d.rstrip()
        target.append(dict_inc_tgt + '/' + d + '.bsh')
        target.append(dict_inc_tgt + '/' + d + '.h')
        bsv = hw_tgt + '/DICT_' + d + '.bsv'
        target.append(bsv)
        all_gen_bsv += [bsv]
    return target, source

# Define the dictionary builder
d_bld = Builder(action = 'hasim-dict --tgt-inc ' + dict_inc_tgt + ' --tgt-hw ' + hw_tgt + ' $SOURCES',
                emitter = dict_emitter)
env.Append(BUILDERS = {'DIC' : d_bld})

# Finally, request dictionary build
d_tgt = env.DIC(dict_inc_tgt + 'init.h', env['DEFS']['DICT_SRCS'].split())
tgt += d_tgt

# Compile RRR stubs
#  NOTE: like dictionaries, some files must be created even when no .rrr
#  files exist.
tgt += env.Command(rrr_inc_tgt + 'rrr_service_ids.h',
                   env['DEFS']['RRR_SRCS'].split(),
                   'hasim-rrr-stubgen --odir ' + rrr_inc_tgt + ' --mode stub --target hw --type server $SOURCES')

#
# Compile generated BSV stubs
#
def emitter_bo(target, source, env):
    target.append(str(target[0]).replace('.bo', '.bi'))
    return target, source

def compile_bo(source, target, env, for_signature):
    bdir = os.path.dirname(str(target[0]))
    cmd = BSC + ' ' + BSC_FLAGS + \
          ' -bdir ' + bdir + ' -vdir ' + bdir + ' -simdir ' + bdir + ' ' + \
          str(source[0])
    return cmd

bsc = Builder(generator = compile_bo, suffix = '.bo', src_suffix = '.bsv',
              emitter = emitter_bo)

env.Append(BUILDERS = {'BSC' : bsc})

for d in all_gen_bsv:
    bo = os.path.dirname(d) + '/' + TMP_BSC_DIR + '/' + os.path.splitext(os.path.basename(d))[0] + '.bo'
    d_bsv_tgt = env.BSC(bo, d)
    tgt += d_bsv_tgt

#
# Build everything
#
if tgt != []:
    Default(tgt)
