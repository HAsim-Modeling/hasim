: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

use strict;
use warnings;
use Getopt::Long qw(:config no_auto_abbrev no_ignore_case pass_through);

##
## Benchmark run script
##

sub ExecModel($);
sub Exec($$);
sub ReadConfig($);


#############################################################################
#############################################################################
##
## Start by figuring out the model location and type.
##
#############################################################################
#############################################################################

my %config;

ReadConfig("config/env.sh");
ReadConfig("$config{modelDir}/config/env.sh");

##
## Pseudo-enumeration of possible model types
##
my $MODEL_FPGA = 1;                     # Model runs on FPGA hardware
my $MODEL_BLUESIM = 2;                  # Bluesim
my $MODEL_VSIM = 3;                     # Verilog simulator

my $mType = 0;

if (-f "$config{modelDir}/$config{model}_hw.download") {
    $mType = $MODEL_FPGA;
}
elsif (-f "$config{modelDir}/$config{model}_hw.exe") {
    $mType = $MODEL_BLUESIM;
}
elsif (-f "$config{modelDir}/$config{model}_hw.vexe") {
    $mType = $MODEL_VSIM;
}
else {
    die("Can't determine model type");
}

#############################################################################
#############################################################################
##
## Process command line arguments
##
#############################################################################
#############################################################################

my $help = 0;
my $gdb = 0;
my $noProgram = 0;
my $noReserve = 0;
my $funcpPrefix = "";
my $funcpSuffix = "";
my $noshowfp = 0;
my $showfp = undef;

my $status = GetOptions("help!" => \$help,
                        "gdb!" => \$gdb,
                        "noprogram!" => \$noProgram,
                        "noreserve!" => \$noReserve,
                        "funcp-prefix=s" => \$funcpPrefix,
                        "funcp-suffix=s" => \$funcpSuffix,
                        "noshowfp!" => \$noshowfp,
                        "showfp:s" => \$showfp,
                       );

if ($help || ! $status) {
    print STDERR "\nArguments:\n";
    print STDERR "   [--gdb]                 Invokes the software side in gdb\n";
    print STDERR "   [--noprogram]           Skips the FPGA load and reservation steps\n";
    print STDERR "   [--noreserve]           Skips the FPGA reservation steps\n";
    print STDERR "   [--funcp-prefix=\"<prefix>\"]\n";
    print STDERR "                           Prepend prefix to HAsim's --funcp argument\n";
    print STDERR "   [--funcp-suffix=\"<suffix>\"]\n";
    print STDERR "                           Append suffix to HAsim's --funcp argument\n";

    if ($config{isHybridModel}) {
        my $cmd = "$config{modelDir}/$config{model} --help-run-append";
        system($cmd);
    }

    exit(1);
}

# Put quotation marks back on arguments that have spaces since they will be
# passed through a shell once more.
foreach my $i ( 0 .. $#ARGV ) {
    if (($ARGV[$i] =~ /\s/) && ! ($ARGV[$i] =~ /['"]$/)) {
        $ARGV[$i] = '"' . $ARGV[$i] . '"';
    }
}

#############################################################################
#############################################################################
##
## Adjust model arguments
##
#############################################################################
#############################################################################

# Show front panel?
if ($noshowfp) {
    $showfp = 'none';
}
elsif (defined($showfp)) {
    # Specified on the run command line
    $showfp = 'gui' if ($showfp eq '');
}
elsif ($config{feeder} eq 'none') {
    # For null feeder default to showing LEDs on stdout
    $showfp = 'stdout';
}
else {
    # Other models have heartbeats
    $showfp = 'none';
}

if ($config{feeder} eq 'm5') {
    # Tell m5 to be quiet
    $config{feedFlags} = "--quiet " . $config{feedFlags};
}

my $feedFlags = "${funcpPrefix} $config{feedFlags} ${funcpSuffix}";

my $cmd = "$config{modelDir}/$config{model} --modeldir=$config{modelDir} --workload=$config{workload} --showfp=${showfp} --funcp=\"${feedFlags}\" $config{genFlags}";
foreach my $c (@ARGV) {
    $cmd .= " $c";
}

# Adjust the arguments for Bluesim if it is being invoked directly
if (! $config{isHybridModel} && ($mType == $MODEL_BLUESIM)) {
    $cmd =~ s/\s--/ +--/g;

    # Bluesim may expect to load a program from a well known file
    unlink('program.vmh');
    link('program/@BENCHMARK@.@ISA@.vmh', 'program.vmh');
}


#############################################################################
#############################################################################
##
## Load the FPGA and run the model
##
#############################################################################
#############################################################################

if ($mType == $MODEL_FPGA) {
    # Load FPGA
    if (! $noProgram) {
        if (! $noReserve) {
            Exec("hasim-fpga-ctrl --reserve", "Failed to reserve FPGA");
        }

        Exec("hasim-fpga-ctrl --program", "Failed to enter FPGA programming mode");
        Exec("(cd $config{modelDir}; ./$config{model}_hw.download) 2>&1 | tee FPGA_programming.log | grep -e INFO:iMPACT -e Programmed -e Error", "Failed to program FPGA");
        Exec("hasim-fpga-ctrl --activate", "Failed to activate FPGA or driver");
    }
}

# Run the software side or a hardware simulator
my $run_status = 0;
if ($config{isHybridModel} || ($mType != $MODEL_FPGA)) {
    $run_status = ExecModel($cmd);
}

# Create a stats file for null workloads to make regression.launcher happy (HACK)
if ( $config{workload} eq "null" ) {
  system("touch null.stats");
}

if (-f "hasim_events.out") {
    system("sort hasim_events.out -o hasim_events.out.$$; mv -f hasim_events.out.$$ hasim_events.out");
}

if (($mType == $MODEL_FPGA) && ! $noProgram && ! $noReserve) {
    Exec("hasim-fpga-ctrl --drop-reservation", "Failed to drop FPGA reservation");
}

# Done.
exit($run_status);


sub ErrorExit($) {
    my $msg = shift;

    print STDERR "${msg}\n";

    if (($mType == $MODEL_FPGA) && ! $noProgram && ! $noReserve) {
        system("hasim-fpga-ctrl --drop-reservation");
    }

    exit(1);
}


##
## ExecModel --
##   This is the routine that actually invokes the model.  stdout and stderr
##   are logged in a file.  The return value is the exit status of the model.
##
sub ExecModel($) {
    my $cmd = shift;

    if ($gdb) {
        ## gdb needs stdin.  Just use system() and don't do logging.
        system("gdb -args " . $cmd);
        return 0;
    }

    if (! open(P, "${cmd} 2>&1 |")) {
        print STDERR "Error running command: ${cmd}\n";
        return 2;
    }

    if (! open(LOG, ">@BENCHMARK@.@ISA@.out")) {
        print STDERR "Error opening log file @BENCHMARK@.@ISA@.out\n";
    }

    while (1) {
        my $buf;
        my $n = sysread(P, $buf, 4096);

        last if ($n == 0);

        syswrite(STDOUT, $buf);
        syswrite(LOG, $buf);
    }

    close(LOG);

    my $status = 0;

    my $close_ok = close(P);

    if ($? == -1) {
        print STDERR "Model execution failed\n";
        $status = 1;
    }
    elsif ($? & 127) {
        print STDERR "Child died with signal " . ($? & 127) . ", " . (($? & 128) ? 'with' : 'without') . " coredump\n";
        $status = 1;
    }
    elsif (($? >> 8) != 0) {
        $status = $? >> 8;
        print "Model exited with status $status\n";
    }
    elsif (! $close_ok) {
        print STDERR "Model pipe operation failed\n";
        $status = 1;
    }

    return $status;
}


sub Exec($$) {
    my $cmd = shift;
    my $errmsg = shift;

    system($cmd);
    if ($? == -1) {
        ErrorExit("Failed to execute $cmd: $!");
    }
    elsif ($? & 127) {
        ErrorExit("Child died with signal " . ($? & 127) . ", " . (($? & 128) ? 'with' : 'without') . " coredump");
    }
    elsif (($? >> 8) != 0) {
        ErrorExit("${errmsg}");
    }
}


#
# Read the configuration file
#
sub ReadConfig($) {
    my $conf = shift;

    open(CONFIG, "< $conf") or die("Failed to open $conf");
    while (<CONFIG>) {
        chomp;
        my $t = $_;
        $t =~ s/#.*//;
        if ($t =~ /^\s*([^\s]+)\s*=\s*"(.*)"\s*$/) {
            my $c = $1;
            my $v = $2;
            $v =~ s/^["'](.*)["']$/$1/;         # Drop quotation marks
            $config{$c} = $v;
        }
        elsif ($t =~ /^\s*([^\s]+)\s*=\s*([^\s]+)\s*$/) {
            my $c = $1;
            my $v = $2;
            $config{$c} = $v;
        }
    }
}
