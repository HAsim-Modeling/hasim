: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

use strict;
use File::Basename;
use Getopt::Long;

my $debug = 0;

# Search path in Bluespec compiler
my $bscPathArg;
my @bscPath;
my $bscBDir = ".";

my %bsvFiles;
my %bsvDep;             # Dependence on source files.

sub ErrorExit($)
{
    my ($str) = @_;
    print STDERR "Error: ${str}\n";
    exit(1);
}

sub Usage()
{
    my $prog = basename($0);
    print STDERR "Usage:\n";
    print STDERR "  ${prog}: [-p path] <bsv files>\n";
    exit(1);
}

##
## SetSearchPath --
##   Combine user specified search path (-p argument) and the Bluespec compiler's
##   default path.
##
sub SetSearchPath($)
{
    my ($path) = @_;

    ## Figure out Bluespec's default path
    my $default = undef;
    open(BSC, "bsc -help |");
    while (<BSC>)
    {
        chomp;
        my $p = $_;
        if ($p =~ /^import path:/)
        {
            $default = $p;
            $default =~ s/^import path: \.:\s*//;
            $default =~ s/\s*$//;
        }
    }
    close(BSC);
    ErrorExit("Failed to find Bluespec default path") if (! defined($default));

    $bscPathArg = $path;
    if ($path eq '')
    {
        $path = $default;
        $bscPathArg = '+';
    }

    @bscPath = split(':', $path);
    my @defaultPath = split(':', $default);
    for (my $i = 0; $i <= $#bscPath; $i++)
    {
        if ($bscPath[$i] eq '+')
        {
            splice(@bscPath, $i, 1, @defaultPath);
        }
    }

    if ($debug)
    {
        print STDERR "BSC Search Path: " . join(':', @bscPath) . "\n";
    }
}


sub FindBSVFile($)
{
    my ($f) = @_;

    foreach my $s (@bscPath)
    {
        my $p = $s . '/' . $f;
        return $p if (-f $p);
    }

    return undef;
}

sub FindBSVLibrary($)
{
    my ($f) = @_;

    if (! defined$ENV{'BLUESPECDIR'}) {
      ErrorExit("BLUESPECDIR undefined in environment.");
    }

    my $bsc_lib_dir = $ENV{'BLUESPECDIR'};
    
    my $p = $bsc_lib_dir . '/Prelude/' . $f;
    return $p if (-f $p);

    $p = $bsc_lib_dir . '/Libraries/' . $f;
    return $p if (-f $p);

    return undef;
}

sub NoteImport($$)
{
    my ($fName, $impName) = @_;

    # Is it a special library?
    return if (($impName eq "BDPI") || ($impName eq "BVI"));

    # Is it a precompiled library?
    return if (defined(FindBSVLibrary($impName . ".bi")));

    my $imp = FindBSVFile($impName . ".bsv");
    if (! defined($imp))
    {
        ErrorExit("Failed to find $impName imported by $fName");
    }

    print STDERR "  $fName imports $imp\n" if ($debug);

    $bsvDep{$fName}{$imp} = 1;
    ParseBSVFile($imp, 1);
}


##
## Note include files by parsing the `line directive emitted by bsc -E
##
sub NoteIncludes($$)
{
    my ($fName, $s) = @_;

    ##
    ## There may be multiple `line directives on a line.  Loop while we keep
    ## finding them.  Using the $gotOne mechanism instead of looping while
    ## we still see `line avoids an infinite loop in case of parser bugs.
    ##
    my $gotOne = 0;
    do
    {
        $gotOne = 0;
        if ($s =~ /.*`line [0-9]+ "(.+)" [0-9]+/)
        {
            $s =~ s/.*`line [0-9]+ ".+" [0-9]+//;
            $gotOne = 1;
        }

        if ($s =~ /.*`line\((.+),[0-9]+,[0-9]+,[0-9]+\)/)
        {
            $s =~ s/.*`line\(.+,[0-9]+,[0-9]+,[0-9]+\)//;
            $gotOne = 1;
        }

        if ($gotOne)
        {
            # Note dependence on include file.  First we have to find out
            # where it is since bsc -E doesn't give a full path.
            my $inc_base = $1;
            my $inc = $inc_base;
            if (! -f $inc)
            {
                $inc = FindBSVFile($inc);
                if (! defined($inc))
                {
                    ErrorExit("Failed to find include file ${inc_base} included by $fName");
                }
            }

            # bsc compiler emits a really ugly name for the main file with
            # 3 slashes before the leaf.  Compare the inodes of the include
            # file to the base name.
            my $f_ino = (stat($fName))[1];
            $f_ino = -1 if (! defined($f_ino));

            my $i_ino = (stat($inc))[1];
            $i_ino = -2 if (! defined($i_ino));

            if ($i_ino != $f_ino)
            {
                #
                # Set an entry in $bsvInc with a value of 0 to indicate just
                # an include file, not an import.  Be careful not to change
                # a previous import to include state.
                #
                if (! exists($bsvDep{$fName}{$inc}))
                {
                    $bsvDep{$fName}{$inc} = 0;
                }
            }
        }
    }
    while ($gotOne);

    if ($s =~ /`line/)
    {
        print STDERR "Failed to parse `line directive in ${fName}:\n";
        print STDERR "  $s\n";
    }
}


sub ParseBSVFile($$)
{
    my ($fName, $flag) = @_;

    # Already parsed this file?
    return if (exists($bsvFiles{$fName}));
    $bsvFiles{$fName} = $flag;

    print STDERR "Parsing input file ${fName}\n" if ($debug);
    ErrorExit("Can't find file $fName") if (! -f $fName);

    my $inComment = 0;
    my $BSV;
    open($BSV, "bsc -E -wait-for-license -p $bscPathArg $fName |");
    while (<$BSV>)
    {
        chomp;
        my $s = $_;

        # Note included files
        if ($s =~ /`line/)
        {
            NoteIncludes($fName, $s);
        }

        # Drop comments.  This code isn't especially smart about slashes inside
        # quotes, multiline comments, etc.

        $s =~ s/\/\/.*//;             # Drop //...

        if ($inComment)
        {
            if ($s =~ /\*[\)\/]/)     # End with *) or */
            {
                $s =~ s/.*\*[\)\/]//;
                $inComment = 0;
            }
        }

        $s =~ s/\(\*.*\*\)//;           # Drop (*...*)
        $s =~ s/\/\*.*\*\///;           # Drop /*...*/

        $s = '' if ($inComment);

        if ($s =~ /[\(\/]\*/)        # Note start with (* or /*
        {
            $s =~ s/[\(\/]\*.*//;
            $inComment = 1;
        }

        # Simplify lines.  Turn all whitespace into single spaces, no leading spaces.
        $s =~ s/^\s*//;
        $s =~ s/\s+/ /g;

        # Finally ready to look for import statements
        if ($s =~ /^import /)
        {
            # Skip non-Bluespec imports
            if ($s =~ / \= module /)
            {
            }
            else
            {
                my $imp = $s;
                $imp =~ s/^import //;
                $imp =~ s/[:; ].*//;
                $imp =~ s/^"//;
                $imp =~ s/"$//;
                NoteImport($fName, $imp);
            }
        }
    }
    close($BSV);
}


my $pathArg = '';

if (! GetOptions('bdir=s' => \$bscBDir,
                 'debug!' => \$debug,
                 'p=s' => \$pathArg))
{
    Usage();
}
Usage() if ($#ARGV < 0);

SetSearchPath($pathArg);

foreach my $bsv (@ARGV)
{
    ParseBSVFile($bsv, 0);
}

##
## Emit dependence rules
##
foreach my $bsv (keys %bsvFiles)
{
    
    my $bi = $bsv;
    $bi =~ s/\.bsv$/.bi/;
    $bi =~ s/(.*)\///g;
    my $bdir = $1;
    print "${bdir}/${bscBDir}/${bi}: ${bsv}\n";
    foreach my $dep (keys %{$bsvDep{$bsv}})
    {
        ## Each file depends on the imported .bsv source files and the files
        ## built from those sources

        print "${bdir}/${bscBDir}/${bi}: ${dep}\n";

        if ($bsvDep{$bsv}{$dep} != 0)
        {
            # For imports add dependence on built object
            my $d = $dep;
            $d =~ s/\.bsv$/.bi/;
            $d =~ s/(.*)\///g;
            my $ddir = $1;
            print "${bdir}/${bscBDir}/${bi}: ${ddir}/${bscBDir}/${d}\n";
        }
    }
    print "\n";
}
print "\n";


##
## These pseudo rules note dependence for building all objects and rebuilding
## the dependence file itself.
##
#

# XXX Currently these are commented out because they don't play well with the surrogates.
# These are statically generated instead

#foreach my $bsv (keys %bsvFiles)
#{
#    print ".depends-bsv: ${bsv}\n";
#}
#print "\n";

#print ".PHONY: all_intermediate\n";
foreach my $bsv (keys %bsvFiles)
{
    ## Only describe subordinate files.  The top level file must be built by
    ## a different rule.
    if ($bsvFiles{$bsv} > 0)
    {
        my $b = $bsv;
        $b =~ s/\.bsv$/.bi/;
        $b =~ s/.*\///g;
        #print "all_intermediate: ${bscBDir}/${b}\n";
    }
}
print "\n";

##
## Now for a hack.  Emit hints in the file for finding imported .bsv source files.
## The .bi rule in the Makefile needs this information.
##
foreach my $bsv (keys %bsvFiles)
{
    print "#PATH_BSV: ${bsv}\n";
}
print "\n";

