: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  Martha Mercaldi
#

use File::Basename;
use File::Spec;
use Getopt::Long;

use Asim;
use AsimShell;

use HAsim;

use warnings;
use strict;



############################################################
# command line handling

my $status;

my $help = 0;
my $debug = 0;

# only one of the following command flags should be set
my $configure = 0;
my $nuke = 0;
my $setup = 0;
my $build = 0;
my $run = 0;

# command options
my $buildopt = "all";
my $builddir = undef;
my $benchmark = undef;
my $rundir = undef;
my $model = undef;
my $runopt = "";


my $private = 1;
my $public = 1;
my $relative = 0;

$status = GetOptions( "private!"    => \$private,
                      "public!"     => \$public,
                      "relative!"   => \$relative,
                      "debug"       => \$debug,
                      "configure"   => \$configure,
                      "nuke"        => \$nuke,
                      "setup"       => \$setup,
                      "build"       => \$build,
                      "run"         => \$run,
		      "model=s"     => \$model,
		      "builddir=s"  => \$builddir,
		      "benchmark=s" => \$benchmark,
		      "rundir=s"    => \$rundir,
                      "buildopt=s"  => \$buildopt,
		      "runopt=s"    => \$runopt,
                      "help"        => \$help
		      );
		      
my $prog = basename($0);

if (!$status) {
    HAsim::Util::WARN_AND_DIE("Illegal argument, try '$prog --help'");
}

if ($help) {
    system "perldoc $0";
    exit 0;
}


my $num_commands = $configure + $nuke + $build + $setup + $run;
if ($num_commands != 1) {
    print STDERR "$prog: Must supply exactly one command:\n";
    print STDERR "\t-configure\n";
    print STDERR "\t-nuke\n";
    print STDERR "\t-build\n";
    print STDERR "\t-setup\n";
    print STDERR "\t-run\n";
    exit 0;
}

if (!defined($model)) {
  $model = $ARGV[0];
}


############################################################
# main body of script

Asim::init()
    || die("Unable to initialize Asim::\n");


print "Opening... $model\n" if $debug;
    

if ($configure) {
    print "Configuring build tree for $model . . . ";
    configure_build_tree($model);
} elsif ($nuke) {
    print "Nuking build tree. . . ";
    delete_build_tree($model);
} elsif ($setup) {
    setup_benchmark($model, $benchmark);
} elsif ($build) {
#	WARN_AND_DIE("build command not yet implemented");
    print "Compiling build tree. . . ";
    build_build_tree($model);
} elsif ($run) {
    print "Running model. . . ";
    run_model($model, $benchmark);
#	WARN_AND_DIE("run command not yet implemented");
}

print "done\n";
   
exit 0;

############################################################
# run_model
sub run_model {
    my $modelfile = shift;
    my $benchmarkfile = shift;

    my $model = Asim::Model->new($modelfile);
    
    if (!defined($benchmarkfile)) {
      WARN_AND_DIE("Undefined Benchmark for running.");
    }
    
    if (!defined($rundir)) {
      $rundir = $model->run_dir($benchmarkfile);
    }
    
    my $exe = HAsim::Util::path_append($rundir, "run $runopt");
    
    $status = system("cd $rundir; $exe");

    return 1;
}

#### SETUP
# What are we given? .cfg? or NM.cfx/bmark.cfg
# Essentially open the benchmark.cfg
# Parse the CFG
# Find setup script
# Create the directory in build/model/bm? Or is that rundir?
# Invoke setup script with arguments SRC DEST OTHERS
# SETUP Script: Link to the model. Compile the benchmark. Create the run script.

############################################################
# setup_benchmark
sub setup_benchmark {
    my $modelfile = shift;
    my $benchmarkfile = shift;

    my $model = Asim::Model->new($modelfile);
    
    if (!defined($benchmarkfile)) {
      WARN_AND_DIE("Undefined Benchmark for setup.");
    }
    
    if (!defined($rundir)) {
      $rundir = $model->run_dir($benchmarkfile);
    }
    
    #Actually create rundir
    
    print STDOUT "RUNDir: $rundir\n";
    
    $status = system("rm -rf " . $rundir);
    $status = system("mkdir -p " . $rundir);

    my $benchmark = Asim::Benchmark->new($benchmarkfile);
      
    my $setup_command = $benchmark->setup_command();
    my $setup_args = $benchmark->setup_args();
    my $srcdir = $benchmark->setup_srcdir();
    
    print STDOUT "SCRIPT: $setup_command\n";
   
    #Run the setup script with appropriate params
    
    #DOUBLE IS THE SRC/DST DIR CONSISTENT WITH AMC?
    print STDOUT "COMMAND: $setup_command $srcdir $rundir $setup_args\n";
    $status = system("$setup_command $srcdir $rundir $setup_args");

    return 1;
}

############################################################
# build_build_tree
sub build_build_tree {
    my $modelfile = shift;
    my $model = Asim::Model->new($modelfile);
    
    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    ## NOTE: make target should come from argument to hasim-configure
    $status = system("make -C $builddir $buildopt");

    return 1;
}

############################################################
# delete_build_tree
sub delete_build_tree {
    my $modelfile = shift;
    my $model = Asim::Model->new($modelfile);
    
    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    my $above_builddir = $builddir;
    $above_builddir =~ s/\/pm$//g; # strip off pm directory to make parent first
    $status = system("rm -fr $above_builddir");
    
    return 1;
}


############################################################
# configure_build_tree: Open a model produce build tree,
#                       populated with Makefiles, for it 
sub configure_build_tree {
    my $modelfile = shift;
    my $model = Asim::Model->new($modelfile);

    if (defined(&Asim::Model::embed_submodels)) {
      print "Using Asim::Model embed_submodels\n";
      $model->embed_submodels();
    } else {
      print "Using Asim::Model without embed_submodels\n";
    }   
    # (1) make directories
    make_dirs($model);

    # (2a) make synthesized bsv files
    make_bsvfiles($model);

    # (2) make symlinks
    make_symlinks($model);

    # (3) generate makefiles from templates
    generate_makefile_include($model);
    generate_makefile_top($model);
    generate_makefile_sub($model);

    # (4) generate files needex by Xilinx tools
    HAsim::Xilinx::generate_files($model);

    # (5) make master RRR file
    make_master_rrr_file($model);

    # (6) make dictionary
    make_dictionary($model);

    return 1;
}

############################################################
# make_dirs: Make directories for build tree
sub make_dirs {
    my $model = shift;
    my $root = $model->modelroot();

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    my $dir = HAsim::Util::path_append($builddir,$HAsim::Xilinx::tmp_xilinx_dir);
    $status = system("mkdir -p " . $dir);

    my $bdir = HAsim::Util::path_append($builddir, $HAsim::Bluespec::tmp_bsc_dir);
    $status = system("mkdir -p " . $bdir);
    
    __make_dirs($root,HAsim::Util::path_append($builddir,"hw"), 1);
    return 1;
}

############################################################
# __make_dirs: Recursively make directories for build tree
sub __make_dirs {
    my $module = shift;
    my $parent_dir = shift;
    my $isroot = shift;

    my $my_dir = HAsim::Build::get_module_build_dir($module,$parent_dir);
    if (HAsim::Build::is_synthesis_boundary($module)) {
	$status = system("mkdir -p $my_dir");
        my $bdir = HAsim::Util::path_append($my_dir, $HAsim::Bluespec::tmp_bsc_dir);
        $status = system("mkdir -p " . $bdir);
        #Generate a wrapper bsv file for that directory.
        generate_wrapper($module, $my_dir, $isroot);
        $isroot = 0;
    } 
    
    ## recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__make_dirs($child,$my_dir, $isroot);
    }
    
    return 1;
}

############################################################
# make_master_rrr_file: Make master list of RRR services
sub make_master_rrr_file {
    my $model = shift;
    my $root = $model->modelroot();

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    my $hw_dir = HAsim::Util::path_append($builddir, "hw");

    # obtain global list of all RRR files
    my @rrr_file_list = __get_rrr_files($root, $hw_dir);

    my $root_module_dir = HAsim::Build::get_module_build_dir($root, $hw_dir);

    my $cppfilename = HAsim::Util::path_append($root_module_dir, "rrr_service_ids.h");
    my $bsvfilename = HAsim::Util::path_append($root_module_dir, "rrr_service_ids.bsh");

    CORE::open(CPPFILE, "> $cppfilename");
    CORE::open(BSVFILE, "> $bsvfilename");

    # start generating header files
    print CPPFILE "\#ifndef __RRR_SERVICES__\n";
    print CPPFILE "\#define __RRR_SERVICES__\n";
    print CPPFILE "\n";

    print BSVFILE "\`ifndef __RRR_SERVICES__\n";
    print BSVFILE "\`define __RRR_SERVICES__\n";
    print BSVFILE "\n";

    # create a preprocessor macro for each service
    my $serviceID = 0;
    foreach my $f (@rrr_file_list)
    {
        # call hasim-rrr-stubgen to obtain list of services in each RRR file
        CORE::open(STUBGEN, "hasim-rrr-stubgen -mode=print-service-names $f |")
            || die "make_master_rrr_file: could not run hasim-rrr-stubgen on $f\n";

        while (my $line = <STUBGEN>)
        {
            chomp $line;
            print CPPFILE "\#define $line\_SERVICE_ID $serviceID\n";
            print BSVFILE "\`define $line\_SERVICE_ID $serviceID\n";
            $serviceID = $serviceID + 1;
        }

        CORE::close(STUBGEN);
    }

    # complete header files
    print CPPFILE "\#define NUM_SERVICES $serviceID\n";
    print CPPFILE "\n";
    print CPPFILE "\#endif\n";

    print BSVFILE "\`define NUM_SERVICES $serviceID\n";
    print BSVFILE "\n";
    print BSVFILE "\`endif\n";

    CORE::close(CPPFILE);
    CORE::close(BSVFILE);

    return 1;
}

############################################################
# __get_rrr_files: Recursively get list of RRR files
sub __get_rrr_files {
    my $module = shift;
    my $parent_dir = shift;

    # identify correct directory in build tree
    my $my_dir = HAsim::Build::get_module_build_dir($module, $parent_dir);

    # get list of my own RRR files
    my @rrr_list = $module->sources("RRR", "*");

    # pre-pend absolute path to each file
    my @rrr_list_fullpath = ();
    foreach my $f (@rrr_list)
    {
        my $fullpath = HAsim::Util::path_append($my_dir, $f);
        push(@rrr_list_fullpath, $fullpath);
    }

    # recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules())
    {
        my @sub_rrr_list = __get_rrr_files($child, $my_dir);
        push(@rrr_list_fullpath, @sub_rrr_list);
    }

    return @rrr_list_fullpath;
}

############################################################
# make_bsvfiles: Make asim metatype bsv files
sub make_bsvfiles {
    my $model = shift;
    my $root = $model->modelroot();

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    __make_bsvfiles($root,HAsim::Util::path_append($builddir,"hw"));
    return 1;
}

############################################################
# __make_bsvfiles: Recursively make asim metatype bsv files
sub __make_bsvfiles {
    my $module = shift;
    my $parent_dir = shift;

    # identify correct directory in build tree
    my $my_dir = HAsim::Build::get_module_build_dir($module,$parent_dir);

    ##
    ## For each module generate two files:  a .bsh header file containing
    ## the module's parameters and a .bsv file that will be a wrapper for
    ## compiling the module.
    ##
    ## Clients of the module should INCLUDE the .bsh file, which both
    ## provides the module parameters and import's the Bluespec interface.
    ##

    my $provides = $module->provides();
    my $bshfile = HAsim::Util::path_append($my_dir,"$provides.bsh");
    my $bsvfile = HAsim::Util::path_append($my_dir,"$provides.bsv");

    CORE::open(BSHFILE, ">$bshfile");

    # Bluespec preprocessor doesn't like '-'
    my $safe_provides = $provides;
    $safe_provides =~ s/-/_/g;

    print BSHFILE "//\n";
    print BSHFILE "// Synthesized header file for module: $provides\n";
    print BSHFILE "//\n";
    print BSHFILE "//   This file was created by " . basename($0) . "\n";
    print BSHFILE "//\n";
    print BSHFILE "\n";

    print BSHFILE "`ifndef INCLUDED_MODULE_${safe_provides}\n";
    print BSHFILE "`define INCLUDED_MODULE_${safe_provides}\n";
    print BSHFILE "\n";

    # add defines for parameters
    my @p = ();
    push(@p, $module->parameters());

    foreach my $p (@p) {
      my $pname = $p->name();
      my $pvalue = $p->value();
      
      print BSHFILE "`define $pname $pvalue\n";
    }
    print BSHFILE "\n";

    print BSHFILE "`ifndef BUILDING_MODULE_${safe_provides}\n";
    print BSHFILE "    import ${provides}::*;\n";
    print BSHFILE "`endif\n";

    print BSHFILE "\n";
    print BSHFILE "`endif  // INCLUDED_MODULE_${safe_provides}\n";

    CORE::close(BSHFILE);
    

    CORE::open(BSVFILE, ">$bsvfile");

    print BSVFILE "//\n";
    print BSVFILE "// Synthesized compilation file for module: $provides\n";
    print BSVFILE "//\n";
    print BSVFILE "//   This file was created by " . basename($0) . "\n";
    print BSVFILE "//\n";
    print BSVFILE "\n";

    # Prevent circular imports
    print BSVFILE "`define BUILDING_MODULE_${safe_provides}\n";
    print BSVFILE "`include \"${provides}.bsh\"\n";
    print BSVFILE "\n";

    # Add includes of public and private bsc files
    if ($public) {
        foreach my $f ($module->sources("BSV", "PUBLIC")) {
            print BSVFILE "`include \"$f\"\n";
        }
    }

    CORE::close(BSVFILE);
    
    # recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__make_bsvfiles($child,$my_dir);
    }

    return 1;
}

############################################################
# make_symlinks: Generate symlinks in build tree to source
#                files and to model apm file (for connect script)
sub make_symlinks {
    my $model = shift;

    my $root = $model->modelroot();

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    my $hw_dir = HAsim::Util::path_append($builddir,"hw");
    __make_symlinks($root,$hw_dir);
    
    return 1;
}

############################################################
# __make_symlinks: Recursively generate symlinks in build 
#                  tree
sub __make_symlinks {
    my $module = shift;
    my $parent_dir = shift;

    # identify correct directory in build tree
    my $my_dir = HAsim::Build::get_module_build_dir($module,$parent_dir);

    # for each src file, generate symlink in $my_dir
    my $base_dir = $module->base_dir();
    my @l = ();

    my @types = $module->source_types();
    foreach my $t (@types) {
        if (! ($t =~ '^(DICT)$')) {
            if ($private) {
                push(@l, $module->sources($t, "PRIVATE"));
            }
            if ($public) {
                push(@l, $module->sources($t, "PUBLIC"));
            }
        }
    }

    foreach my $f (@l) {
        my $src = Asim::resolve(HAsim::Util::path_append($base_dir,$f));
        my $tgt = HAsim::Util::path_append($my_dir,$f);

        if (! -e $src) {
          HAsim::Util::WARN_AND_DIE("Module file $f does not exist in $base_dir");
        }
        
        # make src relative
        my $relsrc = File::Spec->abs2rel($src, dirname($tgt));
        $status = system("ln -f -s $relsrc $tgt");
    }

    # recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        __make_symlinks($child,$my_dir);
    }

    return 1;
}



sub note_builddir($) {
    my $replacements_r = shift;

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    # @BUILD_DIR@
    HAsim::Util::hash_set($replacements_r,'@BUILD_DIR@',$builddir);
}

############################################################
# generate_makefile_include: Collect template replacement 
#                            values for model, and generate
#                            $(APM)/pm/Makefile.include
sub generate_makefile_include {
    my $model = shift;

    my $template = HAsim::Build::get_makefile_include_template($model);
    return if (! defined($template));

    my $replacements_r = HAsim::Util::empty_hash_ref();

    HAsim::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);

    # gather other info recursively
    __generate_makefile_include($model->modelroot(),"hw",$replacements_r);

    my $makefile = HAsim::Util::path_append($builddir,"Makefile.include");
    HAsim::Templates::do_replacements($template,$makefile,$replacements_r);
}

############################################################
# __generate_makefile_include: Recursively collect replacements
#                              for Makefile.include
sub __generate_makefile_include {
    my $module = shift;
    my $parent_dir = shift;
    my $replacements_r = shift;

    my $my_dir = HAsim::Build::get_module_build_dir($module,$parent_dir);
    if (HAsim::Build::is_synthesis_boundary($module)) {
	# @ALL_HW_DIRS@
	HAsim::Util::hash_append($replacements_r,":",'@ALL_HW_DIRS@',$my_dir);
    }

    # recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__generate_makefile_include($child,$my_dir,$replacements_r);
    }

}

############################################################
# generate_makefile_top: Collect template replacement values
#                        for model, and generate 
#                        $(APM)/pm/Makefile
sub generate_makefile_top {
    my $model = shift;
    
    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    my $replacements_r = HAsim::Util::empty_hash_ref();
    
    HAsim::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);

    #@ROOT_DIR_HW_MODEL@
    my $root = $model->modelroot();
    if (HAsim::Build::is_synthesis_boundary($root)) {
	HAsim::Util::hash_set($replacements_r,'@ROOT_DIR_HW_MODEL@',$root->provides());
    } else {
	HAsim::Util::WARN_AND_DIE("Root module must be a synthesis boundary");
    }

    # @ROOT_DIR_HW@
    my $my_dir = HAsim::Build::get_module_build_dir($root,"hw");
    HAsim::Util::hash_set($replacements_r,'@ROOT_DIR_HW@',$my_dir);

    HAsim::Util::hash_append($replacements_r, ":", '@ALL_HW_DIRS@', 'dict');

    # gather other info recursively
    __generate_makefile_top($root,"hw",$replacements_r, 1);

    # Generate the makefile
    my $template = HAsim::Build::get_makefile_top_template($model);
    if (defined($template)) {
        my $makefile = HAsim::Util::path_append($builddir,"Makefile");
        HAsim::Templates::do_replacements($template,$makefile,$replacements_r);
    }

    # Generate scons files
    $template = HAsim::Build::get_scons_root_template($model, 'top');
    if (defined($template)) {
        my $scons = HAsim::Util::path_append($builddir, "SConstruct");
        HAsim::Templates::do_replacements($template, $scons, $replacements_r);
    }
}

############################################################
# __generate_makefile_top: Recursively collect replacements
#                          for Makefile.top
sub __generate_makefile_top {
    my $module = shift;
    my $parent_dir = shift;
    my $replacements_r = shift;
    my $is_root = shift;

    my $my_dir = HAsim::Build::get_module_build_dir($module,$parent_dir);
    if (HAsim::Build::is_synthesis_boundary($module)) {
	# @ALL_HW_DIRS@
	HAsim::Util::hash_append($replacements_r,":",'@ALL_HW_DIRS@',$my_dir);

	# @GEN_VS@ - bsc generated .v files

	my $fileroot = HAsim::Build::get_wrapper($module);
	my $v_file = "$fileroot.v";
	HAsim::Util::hash_append($replacements_r," ",'@GEN_VS@',HAsim::Util::path_append($my_dir, $HAsim::Bluespec::tmp_bsc_dir, $v_file));

	# @GEN_BAS@
	my $ba_file = "$fileroot.ba";
	HAsim::Util::hash_append($replacements_r," ",'@GEN_BAS@',HAsim::Util::path_append($my_dir, $HAsim::Bluespec::tmp_bsc_dir, $ba_file));
        
	# @GEN_CXXS@ and @GEN_HS@ are local to the toplevel directory
	my $cxx_file = "$fileroot.cxx";
	HAsim::Util::hash_append($replacements_r," ",'@GEN_CXXS@',HAsim::Util::path_append($cxx_file));
	my $h_file = "$fileroot.h";
	HAsim::Util::hash_append($replacements_r," ",'@GEN_HS@',HAsim::Util::path_append($h_file));
        
        # @GEN_O_DEPS@ makes sure generated .cxx files are compiled in the right order
        my $my_o = HAsim::Build::make_module_name(HAsim::Build::make_wrapper_name($module->provides()));
        my $parent = HAsim::Build::make_module_name(HAsim::Build::make_wrapper_name($parent_dir));
        $parent =~ s/.*\///;
        if (!$is_root)
        {
	  HAsim::Util::hash_append($replacements_r," ",'@GEN_O_DEPS@',"\n\$(TMP_BSC_DIR)/$parent.o: \$(TMP_BSC_DIR)/$my_o.o\n");
        }
    }

    # collect BDPI-exported files and add it to the @BDPI_BAS@ list
    my @bdpi_names = HAsim::Build::get_bdpi_names($module);
    foreach my $n (@bdpi_names) {
        my $fname = "$n.ba";
	    HAsim::Util::hash_append($replacements_r, " ", '@BDPI_BAS@',
                                 HAsim::Util::path_append($my_dir, $HAsim::Bluespec::tmp_bsc_dir, $fname));
    }


    ## @GIVEN_VS@ - raw .v files included in the model

    foreach my $f ($module->sources("VERILOG", "*")) {
        HAsim::Util::hash_append($replacements_r," ",'@GIVEN_VS@',HAsim::Util::path_append($my_dir, $f));
    }

    ## @GIVEN_CS@

    foreach my $f ($module->sources("CPP", "*")) {
        HAsim::Util::hash_append($replacements_r," ",'@GIVEN_CS@',HAsim::Util::path_append($my_dir, $f));
    }

    ## @BDPI_CS@

    foreach my $f ($module->sources("BDPI_C", "*")) {
        # **** HACK **** only push C files, not H files. TODO: Need a more general separation
        #                between to-be-compiled source files and not-to-be-compiled header files
        # **** /HACK ****
        if ($f =~ /\.h$/) {
            # do nothing
        }
        else {
            HAsim::Util::hash_append($replacements_r," ",'@BDPI_CS@',HAsim::Util::path_append($my_dir, $f));
        }
    }

    # recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__generate_makefile_top($child,$my_dir,$replacements_r, 0);
    }

}


############################################################
# generate_makefile_sub: Collect template replacement values
#                        for model, and generate a Makefile
#                        for each directory in the build tree
#                        (one per synthesis boundary) 
sub generate_makefile_sub {
    my $model = shift;
    
    my $replacements_r = HAsim::Util::empty_hash_ref();
    HAsim::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);
    __generate_makefile_sub($model,$model->modelroot(),"hw",$replacements_r);
}

############################################################
# __generate_makefile_sub: Recursively collect template 
#                          replacement values and generate
#                          Makefiles, one per directory
#                          in the build tree
sub __generate_makefile_sub {
    my $model = shift;
    my $module = shift;
    my $parent_dir = shift;
    my $replacements_r = shift;

    my $current_replacements_r = $replacements_r;
    my $my_dir = $parent_dir;

    if (HAsim::Build::is_synthesis_boundary($module)) {

	# OVERRIDE non-synth-boundary settings
	# 1. instantiate new hash for synthesis boundary
	$current_replacements_r = HAsim::Util::empty_hash_ref();
	# 2. update path
	$my_dir = HAsim::Util::path_append($parent_dir,$module->provides());

	## @DIR@
	HAsim::Util::hash_set($current_replacements_r,'@DIR@',$module->provides());
	
	## @FULL_DIR@
	HAsim::Util::hash_set($current_replacements_r,'@FULL_DIR@',"$builddir/$my_dir");
	
	## @DOTS_TO_MAKEFILE_INCL@
	my $dots_path = $my_dir;
	$dots_path =~ s/([^\/])+/../g;
	HAsim::Util::hash_set($current_replacements_r,'@DOTS_TO_MAKEFILE_INCL@',$dots_path);
        
        
        my $my_wrap = HAsim::Build::make_wrapper_name($module->provides());
        my $my_bsv = "${my_wrap}.bsv";
        HAsim::Util::hash_append($current_replacements_r," ",'@WRAPPER_BSVS@',$my_bsv);
    }

    ## @SUBDIRS@ & @SUBDIR_BAS@
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	
	if (HAsim::Build::is_synthesis_boundary($child)) {
	    my $subdir = $child->provides();
	    HAsim::Util::hash_append($current_replacements_r," ",'@SUBDIRS@',$subdir);
            generate_surrogate_deps($current_replacements_r, $child, '');

	}
    }

    ## FOR BOTH SYNTH & NON_SYNTH
    ## @BSVS@ & @SRCS@ @CSRCS@

    my $deps = "";
    my $mod_bsv = $module->provides() . ".bsv";

    if ($private) {
        foreach my $f ($module->sources("BSV", "PRIVATE")) {
            HAsim::Util::hash_append($current_replacements_r, " ", '@BSVS@', $f);
            $deps = $deps . " $f";
        }
        foreach my $f ($module->sources("CPP", "PRIVATE")) {
            HAsim::Util::hash_append($current_replacements_r, " ", '@CSRCS@', $f);
            # $deps = $deps . " $f";
        }
    }
    if ($public) {
        foreach my $f ($module->sources("BSV", "PUBLIC")) {
            HAsim::Util::hash_append($current_replacements_r, " ", '@BSVS@', $f);
            $deps = $deps . " $f";
        }
        foreach my $f ($module->sources("CPP", "PUBLIC")) {
            HAsim::Util::hash_append($current_replacements_r, " ", '@CSRCS@', $f);
            # $deps = $deps . " $f";
        }
    }

    # collect BDPI-exported names
    my @bdpi_names = HAsim::Build::get_bdpi_names($module);
    foreach my $n (@bdpi_names) {
        my $fname = "$n.ba";
	    HAsim::Util::hash_append($current_replacements_r, " ", '@BDPI_BAS@', $fname);
    }

    my $mod_rule = "\n$mod_bsv: $deps\n\ttouch \$\@\n";
    HAsim::Util::hash_append($current_replacements_r, " ", '@GEN_BSVS@', $mod_bsv);

    #recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__generate_makefile_sub($model,$child,$my_dir,$current_replacements_r);
    }

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    # on the way up, possibly generate makefile
    if (HAsim::Build::is_synthesis_boundary($module)) {
        # Generate makefile
	my $template = HAsim::Build::get_makefile_sub_template($model,$module);
        if (defined($template)) {
            my $makefile = HAsim::Util::path_append($builddir,$my_dir,"Makefile");
            HAsim::Templates::do_replacements($template,$makefile,$current_replacements_r);
        }

        # Generate scons file
        $template = HAsim::Build::get_scons_hw_sub_template($model, $module);
        if (defined($template)) {
            my $scons = HAsim::Util::path_append($builddir, $my_dir, "SConscript");
            HAsim::Templates::do_replacements($template, $scons, $current_replacements_r);
        }
    }
}


#############################################################
# Generate surrogate dependencies for turning wires back to
# connections via hasim-connect

sub generate_surrogate_deps
{
  my $replacements_r = shift;
  my $module = shift;
  my $dir = shift;
  
  my $surrogate = $module->provides();
  my $wrapper = HAsim::Build::make_wrapper_name($surrogate);
  
  # @SURROGATE_DEPS@ ensures surrogates are re-generated as necessary
  my $run_connection = "\$(CONNECTION_SCRIPT) \$(APM_FILE) \$@";
  HAsim::Util::hash_append($replacements_r," ",'@SURROGATE_DEPS@',"\n$dir/$surrogate.bsv: $dir/$surrogate/\$(TMP_BSC_DIR)/$wrapper.bi\n\t$run_connection\n");
  
#  my $child_wrap = HAsim::Build::make_wrapper_name($surrogate);
#  my $child_bsv = "${surrogate}/${child_wrap}.bsv";
#  $child_bsv = "$dir/$child_bsv" if ($dir ne '');
#  HAsim::Util::hash_append($replacements_r," ",'@WRAPPER_BSVS@',$child_bsv);
  
  foreach my $child ($module->submodules()) {
    if (HAsim::Build::is_synthesis_boundary($child)) {
      my $subdir = $child->provides();
      my $subdir_wrapper = HAsim::Build::make_wrapper_name($subdir);
      
      generate_surrogate_deps($replacements_r, $child, HAsim::Util::path_append($dir, $surrogate));
    }
  }
}


#############################################################
# Generate a wrapper file that turns all Connections to wires
# at a synthesis boundary.

sub generate_wrapper {
    my $module = shift;
    my $dirname = shift;
    my $isroot = shift;

    my $metatype = $module->provides();
    my $wrapper = HAsim::Build::make_wrapper_name($metatype) . ".bsv";
    
    CORE::open(WRAPPER, "> $dirname/$wrapper") || return undef;

    print WRAPPER "// These are well-known/required hasim modules\n";
    if ($isroot) {
      print WRAPPER "import soft_connections_alg::*;\n";
    } else {
      print WRAPPER "import smart_synth_boundaries::*;\n";
    }

    print WRAPPER "\n";

    #
    # add defines for parameters
    #   TBD: Share this code with hasim-configure

    print WRAPPER "// These are the parameters for the module\n";

    my @p = ();
    push(@p, $module->parameters());

    foreach my $p (@p) {
      my $pname = $p->name();
      my $pvalue = $p->value();

      print WRAPPER "`define $pname $pvalue\n";
    }
    print WRAPPER "\n";

    #
    # add includes for public sources
    #   Note: Can't just include 'provides' name since it bsc won't 
    #         find the correct instance of the file
    #

    print WRAPPER "// import non-synthesis public files\n";
    foreach my $file_root ($module->sources("BSV", "PUBLIC")) {
        print WRAPPER "`include \"$file_root\"\n";
    }
    print WRAPPER "\n";

    print WRAPPER "// import non-synthesis private files\n";
    foreach my $file_root ($module->sources("BSV", "PRIVATE")) {
        print WRAPPER "`include \"$file_root\"\n";
    }
    print WRAPPER "\n";

    if ($isroot) {
        print WRAPPER "\n";
        print WRAPPER "import physical_platform::*;\n";
        print WRAPPER "\n";
        print WRAPPER "(* synthesize *)\n";
	print WRAPPER "module " . HAsim::Build::make_module_name(HAsim::Build::make_wrapper_name($metatype)) . " (TOP_LEVEL_WIRES);\n";    
    } else {
        print WRAPPER "(* synthesize *)\n";
	print WRAPPER "module " . HAsim::Build::make_module_name(HAsim::Build::make_wrapper_name($metatype)) . " (WithConnections);\n";    
    }
    print WRAPPER "\n";

    my @child_info_vars = ();
    my $synth_id = HAsim::Build::get_synthesis_boundary_name($module);
    print WRAPPER "    // instantiate own module\n";
    if ($isroot) {
	print WRAPPER "    let m <- instantiateWithConnections($synth_id);\n";
    } else {
	print WRAPPER "    let m <- instantiateSmartBoundary($synth_id);\n";
    }
    print WRAPPER "\n";

    print WRAPPER "    return m;\n";
    print WRAPPER "\n";

    print WRAPPER "endmodule\n";

    CORE::close(WRAPPER);
}

############################################################
# make_dictionary: Build the dictionary in a separate tree
#
sub make_dictionary {
    my $model = shift;
    my $my_dir = 'dict';

    my $dir = HAsim::Util::path_append($builddir, "dict");
    $status = system("mkdir -p " . $dir);

    my $template = HAsim::Build::get_scons_root_template($model, 'dict');
    return if (! defined($template));
    $status = system("mkdir -p " . $dir . "/src");

    my $replacements_r = HAsim::Util::empty_hash_ref();

    HAsim::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);

    my $scons = HAsim::Util::path_append($builddir, "dict", "SConstruct");
    HAsim::Templates::do_replacements($template, $scons, $replacements_r);

    # gather other info recursively
    __make_dictionary($model->modelroot(), $dir);
}

############################################################
# __make_dictionary: recursively build dictionary links
#
sub __make_dictionary {
    my $module = shift;
    my $parent_dir = shift;

    my $base_dir = $module->base_dir();

    # Link to dictionaries
    my @d = $module->sources("DICT", "*");
    foreach my $f (@d) {
        my $src = Asim::resolve(HAsim::Util::path_append($base_dir,$f));
        my $tgt = HAsim::Util::path_append($parent_dir, 'src', $f);

        if (! -e $src) {
          HAsim::Util::WARN_AND_DIE("Module file $f does not exist in $base_dir");
        }
        
        # make src relative
        my $relsrc = File::Spec->abs2rel($src, dirname($tgt));
        $status = system("ln -f -s $relsrc $tgt");
    }

    # recurse
    HAsim::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__make_dictionary($child, $parent_dir);
    }

}
