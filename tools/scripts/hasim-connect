
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  
#


use File::Basename;
use Getopt::Long;

use Asim;
use AsimShell;

############################################################
# handle command line

my $status;

my $help = 0;
my $debug = 0;


$status = GetOptions( "debug"      => \$debug,
                      "help"       => \$help
		      );

my $prog = basename($0);

if (!$status) {
    print STDERR "$prog: Illegal argument, try '$prog --help'\n";
    exit 0;
}

if ($help) {
    system "perldoc $0";
    exit 0;
}

############################################################
# main body of script

my $modelfile = shift;
my $metatype = shift;

Asim::init()
    || die("Unable to initialize Asim::\n");


print_wrapper($modelfile,$metatype) ;

exit 0;


############################################################
# 
sub print_wrapper {
    my $modelfile = shift;
    my $metatype = shift;

    my $model = Asim::Model->new($modelfile);
    my $root = $model->modelroot();
    my $module = $root->find_module_providing($metatype);

    my $wrapper = $metatype . "_Wrapper.bsv";
    CORE::open(WRAPPER, "> $wrapper") || return undef;

    print WRAPPER "import ModuleCollect::*;\n";
    print WRAPPER "import HASim::*;\n";
    print WRAPPER "import Connections::*;\n";
    print WRAPPER "\n";

    print WRAPPER "// import children wrappers\n";
    foreach my $submodule (get_sub_synth_modules($module,1)) {
	my $file_root = $submodule->provides() . "_Wrapper";
	print WRAPPER "import $file_root\::*;\n";
    }
    print WRAPPER "\n";

    print WRAPPER "// import non-synthesis children\n";
    foreach my $file_root (get_srcs_at_synth_boundary($root,$module,0)) {
	print WRAPPER "import $file_root\::*;\n";
    }
    print WRAPPER "\n";

    print WRAPPER "(* synthesize *)\n";
    print WRAPPER "module [Module] mk_" . $metatype . "_Wrapper (WithConnections);\n";
    print WRAPPER "\n";

    my $indent = "   ";

    my @child_info_vars = ();
    foreach my $submodule (get_sub_synth_modules($module,1)) {

	my $submetatype = $submodule->provides();
	
	print WRAPPER "$indent // $submetatype\n";	

	my $wrap_var = "wrap_" . $submetatype;
	my $mk_wrapper = "mk_" . $submetatype . "_Wrapper";
	print WRAPPER "$indent // 1. instantiate wrapper\n";
	print WRAPPER "$indent WithConnections $wrap_var <- $mk_wrapper();\n";
	
	my $log_file = 
	    $model->build_dir() . "/" . 
	    get_module_build_dir($module,$root,"arch") . "/" .
	    $submetatype . "/" .
	    $mk_wrapper . ".log";

        print "<<<< $log_file\n";
	
	print WRAPPER "$indent // 2. log sends & recvs\n";
	my @conns = parse_dangling_connections($log_file);
	my @sends_exprs = ();
	my @recvs_exprs = ();

	foreach my $conn_r (@conns) {
	    my $expr = "tuple2(\"" . $conn_r->[2] . "\", " . $conn_r->[1] . ")";

	    if ($conn_r->[0] eq "Send") {
		push (@sends_exprs, $expr);
	    } elsif ($conn_r->[0] eq "Rec") {
		push (@recvs_exprs, $expr);
	    } else {
		DIE("Unrecognized type of dangling connection: $1\n");
	    }	    
	}

	my $sends_var = "dsends_" . $submetatype;
	my $recvs_var = "drecvs_" . $submetatype;

	my $sends_cons = get_cons_expr(@sends_exprs);
	my $recvs_cons = get_cons_expr(@recvs_exprs);

	print WRAPPER "$indent let $sends_var = $sends_cons;\n";
	print WRAPPER "$indent let $recvs_var = $recvs_cons;\n";

	my $info_var = "info_" . $submetatype;
	print WRAPPER "$indent // 3. info\n";
	print WRAPPER "$indent let $info_var = tuple3($wrap_var,$sends_var,$recvs_var);\n";
	
	print WRAPPER "\n";
	
	push(@child_info_vars,$info_var);

    }

    print WRAPPER "$indent // join all info\n";
    my $cons_string = get_cons_expr(@child_info_vars);
    print WRAPPER "$indent let info = $cons_string;\n";
    print WRAPPER "\n";

    my $synth_id = get_synthesis_boundary_name($module);
    print WRAPPER "$indent // instantiate own module\n";
    print WRAPPER "$indent let m <- instantiateWithConnections($synth_id, info);\n";
    print WRAPPER "\n";

    print WRAPPER "$indent return m;\n";
    print WRAPPER "\n";

    print WRAPPER "endmodule\n";

    CORE::close(WRAPPER);

}

############################################################
# 
sub get_module_build_dir {
    my $target = shift;
    my $current = shift;
    my $path = shift;

    if ( is_synthesis_boundary($current) ) {
	$path = $path . "/" . $current->provides();
	if ($current->issame($target)) {
	    return $path;
	} 
    }

    foreach my $submodule ($current->submodules()) {
	my $res = get_module_build_dir($target,$submodule,$path);
	if ($res) {
	    return $res;		    
	}
    }

    DIE("Control should never reach here.\n");
}

############################################################
# 
sub get_cons_expr {
    my @vars = @_;

    if ($#vars == -1) {
	return "nil";
    }

    return "cons(" . $vars[0] . ", " . get_cons_expr(@vars[1 .. $#vars]) . ")";
}

############################################################
# 
sub get_sub_synth_modules {
    my $module = shift;
    my $start_module = shift;

    my @module_list = ();
    if (is_synthesis_boundary($module) && $start_module == 0) {
	push (@module_list,$module);
    } else {
#    } elsif (((is_synthesis_boundary($module) && $start_module == 1)) ||
#	     ((!is_synthesis_boundary($module) && $start_module == 0))) {
	foreach my $submodule ($module->submodules()) {
	    push(@module_list,get_sub_synth_modules($submodule,0));
	}
    }
    return @module_list;
}

############################################################
# 
sub get_srcs_at_synth_boundary {
    my $module = shift;
    my $ancestor = shift;
    my $below_ancestor = shift;

    # at ancestor
    if ($module->provides() eq $ancestor->provides()) {
	$below_ancestor = 1;
    } 

    my @srcs = ();
    if ($below_ancestor) {
	foreach my $file ($module->public(),$module->private()) {
	    if ($file =~ /.bsv/) {
		$file =~ s/.bsv//g;
		push(@srcs,$file);
	    }
	}
    }

    # recurse
    foreach my $submodule ($module->submodules()) {
	if (!is_synthesis_boundary($submodule) || !$below_ancestor) {
	    my @result = get_srcs_at_synth_boundary($submodule,$ancestor,$below_ancestor);
	    push(@srcs,@result);
	}
    }

    return @srcs;
}

############################################################
# 
sub parse_dangling_connections {
    my $log_file = shift;

#Compilation message: "HASim.bsv", line 518, column 5: Dangling Send [0]: mem_imem_req
#Compilation message: "HASim.bsv", line 528, column 5: Dangling Rec [0]: mem_imem_resp

    print "parsing: $log_file\n";
    my @conns = ();
    CORE::open(LOG, "< $log_file") || return undef;
    while (my $line = <LOG>) {
	if ($line =~ /.*Dangling\W+(\w+)\W+(\w+)\W+(\w+)\W+/) {
	    my @connection = ($1,$2,$3);
	    push(@conns, [@connection]);
	}
    }
    CORE::close(LOG);

    return @conns;
}

sub get_provider {
    my $module = shift;
    my $metatype = shift;

    if ($module->provides() eq $metatype) {
	return $module;
    }

    # recurse
    foreach my $submodule ($module->submodules()) {
	my $result = get_provider($submodule,$metatype);
	if ($result != 0) {
	    return $result;
	}
    }

    return 0;
}

sub get_synthesis_boundary_name {
    my $module = shift;
    foreach $param_r ($module->parameters()) {
	my %param = %{$param_r};
	if ($param{'name'} eq "SYNTH_BOUNDARY") {
	    return $param{'default'};
	}
    }
    die "$prog: get_synthesis_boundary_name called on non-synthesis boundary module\n";
}

sub is_synthesis_boundary {
    my $module = shift;

    foreach $param_r ($module->parameters()) {
	my %param = %{$param_r};
	if ($param{'name'} eq "SYNTH_BOUNDARY") {
	    return 1;
	}
    }
    return 0;
}

sub WARN {
    my $msg = shift;
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
    print STDERR "$filename: ($subroutine) [called from ln $line]: $msg\n";
}

sub DIE {
    my $msg = shift;
    WARN($msg);
    die;
}
