: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  
#


use File::Basename;
use Getopt::Long;

use Asim;
use AsimShell;

use HAsim;

############################################################
# handle command line

my $status;

my $help = 0;
my $debug = 0;
my $dynsize = 0;

$status = GetOptions( "debug!"     => \$debug,
                      "help!"      => \$help,
                      "dynsize!"   => \$dynsize,
		      );

my $prog = basename($0);

if (!$status) {
    print STDERR "$prog: Illegal argument, try '$prog --help'\n";
    exit 0;
}

if ($help) {
    system "perldoc $0";
    exit 0;
}

############################################################
# main body of script

my $modelfile = shift;
my $targetfile = shift;

Asim::init()
    || die("Unable to initialize Asim::\n");

if ($dynsize) {
    create_dynsize_bsh($targetfile, $modelfile);
}
else {
    create_surrogate($modelfile, $targetfile);
}

exit 0;


############################################################
# 

sub create_dynsize_bsh {
    my $tgt_file = shift;
    my $log_file = shift;

    my $metatype = basename($log_file);
    $metatype =~ s/_Wrapper\.log$//;

    my @conns = parse_dangling_connections($log_file);
    my $sends = 0;
    my $recvs = 0;
    foreach my $conn_r (@conns) {
        if ($conn_r->[0] eq "Send") {
            $sends += 1;
        } elsif ($conn_r->[0] eq "Rec") {
            $recvs += 1;
        } else {
            DIE("Unrecognized type of dangling connection: $1\n");
        }     
    }

    open(SIZES, "> $tgt_file") or die("Failed to open $tgt_file for writing");
    print SIZES "//\n";
    print SIZES "// Dynamic connection sizes, generated by hasim-connect --dynsize\n";
    print SIZES "//\n\n";
    print SIZES "`ifndef CON_RECV_${metatype}\n";
    print SIZES "`define CON_RECV_${metatype} ${recvs}\n";
    print SIZES "`endif\n\n";
    print SIZES "`ifndef CON_SEND_${metatype}\n";
    print SIZES "`define CON_SEND_${metatype} ${sends}\n";
    print SIZES "`endif\n";
    close(SIZES);
}

############################################################
# 

sub create_surrogate {
    my $modelfile = shift;
    my $filename = shift;

    my $metatype = basename($filename);
    $metatype =~ s/\.bsv//;

    my $model = Asim::Model->new($modelfile);

    if (defined(&Asim::Model::embed_submodels)) {
      print "Using Asim::Model embed_submodels\n";
      $model->embed_submodels();
    } else {
      print "Using Asim::Model without embed_submodels\n";
    }       

    my $root = $model->modelroot();

    my $module = $root->find_module_providing($metatype);

    my $indent = "   ";

    my $synth_id = HAsim::Build::get_synthesis_boundary_name($module);

    my $wrap_var = "wrap_" . $metatype;
    my $mk_wrapper = make_module_name(make_wrapper_name($metatype));

    my $log_file = logfile_name($filename, $metatype);

    CORE::open(SURROGATE, "> $filename") or die("Failed to open $filename for writing");
    print SURROGATE "//\n";
    print SURROGATE "// Dynamic connection surrogate, generated by hasim-connect\n";
    print SURROGATE "//\n\n";
    print SURROGATE "// Surrogate for $metatype\n";

    print SURROGATE "\n";
    print SURROGATE "// Sizes from wrapper\n";
    print SURROGATE "`include \"${metatype}/${metatype}_Wrapper_con_size.bsh\"\n";

    print SURROGATE "\n";
    print SURROGATE "// These are well-known/required hasim modules\n";
    print SURROGATE "import soft_connections::*;\n";
    print SURROGATE "import smart_synth_boundaries::*;\n";
    print SURROGATE "\n";

    print SURROGATE "import " . make_wrapper_name($metatype) . "::*;\n";

    print SURROGATE "module [Connected_Module] $synth_id ();\n";    
    print SURROGATE "$indent // 1. instantiate wrapper\n";
    print SURROGATE "$indent WithConnections#(`CON_RECV_${metatype}, `CON_SEND_${metatype}) $wrap_var <- $mk_wrapper();\n";

    print SURROGATE "$indent // 2. log sends & recvs\n";
    my @conns = parse_dangling_connections($log_file);
    my @sends_exprs = ();
    my @recvs_exprs = ();

    foreach my $conn_r (@conns) {
        my $expr = "tuple3(\"" . $conn_r->[3] . "\", \"" . $conn_r->[1] . "\", " . $conn_r->[2] . ")";

        if ($conn_r->[0] eq "Send") {
            push (@sends_exprs, $expr);
        } elsif ($conn_r->[0] eq "Rec") {
            push (@recvs_exprs, $expr);
        } else {
            DIE("Unrecognized type of dangling connection: $1\n");
        }     
    }

    my $sends_var = "dsends_" . $metatype;
    my $recvs_var = "drecvs_" . $metatype;

    my $sends_cons = get_cons_expr(@sends_exprs);
    my $recvs_cons = get_cons_expr(@recvs_exprs);

    print SURROGATE "$indent let $sends_var = $sends_cons;\n";
    print SURROGATE "$indent let $recvs_var = $recvs_cons;\n";

    print SURROGATE "$indent addConnections($wrap_var, $sends_var, $recvs_var);\n";

    print SURROGATE "endmodule\n";
    print SURROGATE "\n";

    CORE::close(SURROGATE);
}

############################################################
# 
sub logfile_name {
    my $ofile_name = shift;
    my $metatype = shift;
  
    return dirname($ofile_name) .
        "/${metatype}/.bsc/" .
        make_wrapper_name($metatype) . ".log";
}

############################################################
# 
sub make_wrapper_name {
    my $name = shift;
  
    return $name . "_Wrapper";
}

############################################################
# 
sub make_module_name {
    my $name = shift;
  
    return "mk_" . $name;
}


##########################################################
# 
sub get_module_build_dir {
    my $target = shift;
    my $current = shift;
    my $path = shift;

    my $tmp = $target->provides();
    my $tmp2 = $current->provides();
#    print "SEARCHING FOR $tmp FROM $tmp2\n";

    if ( HAsim::Build::is_synthesis_boundary($current) ) {
	$path = $path . "/" . $current->provides();
	if ($current->issame($target)) {
#	    print "RETURNING PATH: $path\n";
	    return $path;
	}
    }

    foreach my $submodule ($current->submodules()) {
	my $tmp3 = $submodule->provides();
#	print "   CHILD $tmp3\n";
	my $res = get_module_build_dir($target,$submodule,$path);
	if ($res) {
#	    print "SUCCESS\n";
	    return $res;		    
	}
    }
    return "";
#    print "DONE\n";
#    DIE("Control should never reach here.\n");
}

############################################################
# 
sub get_cons_expr {
    my @vars = @_;

    if ($#vars == -1) {
	return "List::nil";
    }

    return "cons(" . $vars[0] . ", " . get_cons_expr(@vars[1 .. $#vars]) . ")";
}


############################################################
# 
sub parse_dangling_connections {
    my $log_file = shift;

#Compilation message: "HASim.bsv", line 518, column 5: Dangling Send {<type>} [0]: mem_imem_req
#Compilation message: "HASim.bsv", line 528, column 5: Dangling Rec {<type>} [0]: mem_imem_resp

    #print "parsing: $log_file\n";
    my @conns = ();
    CORE::open(LOG, "< $log_file") || return undef;
    while (my $line = <LOG>) {
        if ($line =~ /^Compilation message: .*: Dangling /) {
            if ($line =~ /.*Dangling (\w+) {(.*)} \[(\d+)\]: (\w+)/) {
                my @connection = ($1,$2,$3,$4);
                push(@conns, [@connection]);
            }
            else {
                DIE("Malformed dangling connection message");
            }
        }
    }
    CORE::close(LOG);

    return @conns;
}

sub WARN {
    my $msg = shift;
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
    print STDERR "$filename: ($subroutine) [called from ln $line]: $msg\n";
}

sub DIE {
    my $msg = shift;
    WARN($msg);
    die;
}
