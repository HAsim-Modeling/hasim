:
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  
#


use File::Basename;
use Getopt::Long;

use Asim;
use AsimShell;

use HAsim;

############################################################
# handle command line

my $status;

my $help = 0;
my $debug = 0;


$status = GetOptions( "debug"      => \$debug,
                      "help"       => \$help
		      );

my $prog = basename($0);

if (!$status) {
    print STDERR "$prog: Illegal argument, try '$prog --help'\n";
    exit 0;
}

if ($help) {
    system "perldoc $0";
    exit 0;
}

############################################################
# main body of script

my $modelfile = shift;
my $targetfile = shift;

my $filename = $targetfile;
$targetfile =~ s/.*\/(.*).bsv//;
my $metatype = $1;


Asim::init()
    || die("Unable to initialize Asim::\n");

create_surrogate($modelfile, $filename, $metatype);

exit 0;


############################################################
# 


sub create_surrogate {
    my $modelfile = shift;
    my $filename = shift;
    my $metatype = shift;

    my $model = Asim::Model->new($modelfile);

    if (defined(&Asim::Model::embed_submodels)) {
      print "Using Asim::Model embed_submodels\n";
      $model->embed_submodels();
    } else {
      print "Using Asim::Model without embed_submodels\n";
    }       

    my $root = $model->modelroot();

    my $module = $root->find_module_providing($metatype);

    my $indent = "   ";

    my $synth_id = HAsim::Build::get_synthesis_boundary_name($module);

    my $wrap_var = "wrap_" . $metatype;
    my $mk_wrapper = make_module_name(make_wrapper_name($metatype));

    my $log_file = 
       $model->build_dir() . "/" . 
       get_module_build_dir($module,$root,"arch") . "/" .
       "/.bsc/" .
       make_wrapper_name($metatype) . ".log";

    #print "<<<< $log_file\n";

    if (need_to_regenerate_surrogate($filename, $log_file))
    {
      CORE::open(SURROGATE, "> $filename");
      print SURROGATE "$indent // Surrogate for $metatype\n";


      print SURROGATE "\n";
      print SURROGATE "// These are well-known/required hasim modules\n";
      print SURROGATE "import soft_connections::*;\n";
      print SURROGATE "import smart_synth_boundaries::*;\n";
      print SURROGATE "\n";

      print SURROGATE "import " . make_wrapper_name($metatype) . "::*;\n";

      print SURROGATE "module [Connected_Module] $synth_id ();\n";    
      print SURROGATE "$indent // 1. instantiate wrapper\n";
      print SURROGATE "$indent WithConnections $wrap_var <- $mk_wrapper();\n";

      print SURROGATE "$indent // 2. log sends & recvs\n";
      my @conns = parse_dangling_connections($log_file);
      my @sends_exprs = ();
      my @recvs_exprs = ();

      foreach my $conn_r (@conns) {
          my $expr = "tuple2(\"" . $conn_r->[2] . "\", " . $conn_r->[1] . ")";

          if ($conn_r->[0] eq "Send") {
              push (@sends_exprs, $expr);
          } elsif ($conn_r->[0] eq "Rec") {
              push (@recvs_exprs, $expr);
          } else {
              DIE("Unrecognized type of dangling connection: $1\n");
          }     
      }

      my $sends_var = "dsends_" . $metatype;
      my $recvs_var = "drecvs_" . $metatype;

      my $sends_cons = get_cons_expr(@sends_exprs);
      my $recvs_cons = get_cons_expr(@recvs_exprs);

      print SURROGATE "$indent let $sends_var = $sends_cons;\n";
      print SURROGATE "$indent let $recvs_var = $recvs_cons;\n";

      print SURROGATE "$indent addConnections($wrap_var, $sends_var, $recvs_var);\n";

      print SURROGATE "endmodule\n";
      print SURROGATE "\n";

      CORE::close(SURROGATE);
    }
    else
    {
      print "hasim-connect: No need to re-generate $filename\n";
    }
}

############################################################
# 
sub make_wrapper_name {
    my $name = shift;
  
    return $name . "_Wrapper";
}

############################################################
# 
sub make_module_name {
    my $name = shift;
  
    return "mk_" . $name;
}

############################################################
# 
sub get_module_build_dir2 {

    my $model = shift;
    my $module = shift;

    my $current = $module;
    my $path = "";

    while (defined $current) {
	my $dir = "";
	if (HAsim::Build::is_synthesis_boundary($current)) {
	    my $dir = $current->provides();
	}

	if (!($dir eq "")) {
	    $path = $dir . "/" . $path;
        }
	$current = $current->parent();

    }

    return $path;
}

##########################################################
# 
sub get_module_build_dir {
    my $target = shift;
    my $current = shift;
    my $path = shift;

    my $tmp = $target->provides();
    my $tmp2 = $current->provides();
#    print "SEARCHING FOR $tmp FROM $tmp2\n";

    if ( HAsim::Build::is_synthesis_boundary($current) ) {
	$path = $path . "/" . $current->provides();
	if ($current->issame($target)) {
#	    print "RETURNING PATH: $path\n";
	    return $path;
	}
    }

    foreach my $submodule ($current->submodules()) {
	my $tmp3 = $submodule->provides();
#	print "   CHILD $tmp3\n";
	my $res = get_module_build_dir($target,$submodule,$path);
	if ($res) {
#	    print "SUCCESS\n";
	    return $res;		    
	}
    }
    return "";
#    print "DONE\n";
#    DIE("Control should never reach here.\n");
}

############################################################
# 
sub get_cons_expr {
    my @vars = @_;

    if ($#vars == -1) {
	return "List::nil";
    }

    return "cons(" . $vars[0] . ", " . get_cons_expr(@vars[1 .. $#vars]) . ")";
}

############################################################
# 
sub get_sub_synth_modules {
    my $module = shift;
    my $start_module = shift;

    my @module_list = ();
    if (HAsim::Build::is_synthesis_boundary($module) && $start_module == 0) {
	push (@module_list,$module);
    } else {
#    } elsif (((is_synthesis_boundary($module) && $start_module == 1)) ||
#	     ((!is_synthesis_boundary($module) && $start_module == 0))) {
	foreach my $submodule ($module->submodules()) {
	    push(@module_list,get_sub_synth_modules($submodule,0));
	}
    }
    return @module_list;
}

############################################################
# 
sub parse_dangling_connections {
    my $log_file = shift;

#Compilation message: "HASim.bsv", line 518, column 5: Dangling Send [0]: mem_imem_req
#Compilation message: "HASim.bsv", line 528, column 5: Dangling Rec [0]: mem_imem_resp

    #print "parsing: $log_file\n";
    my @conns = ();
    CORE::open(LOG, "< $log_file") || return undef;
    while (my $line = <LOG>) {
	if ($line =~ /.*Dangling\W+(\w+)\W+(\w+)\W+(\w+)\W+/) {
	    my @connection = ($1,$2,$3);
	    push(@conns, [@connection]);
	}
    }
    CORE::close(LOG);

    return @conns;
}

sub parse_existing_dangling_connections {
    my ($filename, $ref_sends, $ref_recvs) = @_;

    

#    let dsends_hasim_funcp_memstate = cons(tuple2("mem_imem_resp", 0), cons(tuple2("mem_dmem_resp", 1), List::nil));
#    let drecvs_hasim_funcp_memstate = cons(tuple2("mem_imem_req", 0), cons(tuple2("mem_dmem_req", 1), cons(tuple2("mem_commit", 2), cons(tuple2("fp_memstate_kill", 3), List::nil))));

    #print "parsing: $filename\n";
    CORE::open(EXISTING, "< $filename") || return undef;
    
    
    while (my $line = <EXISTING>) {
	if ($line =~ m/let dsends_/) {
          @{$ref_sends} = $line =~ m/tuple2\("(\w+)", \d*\)/g;
	}
	elsif ($line =~ m/let drecvs_/) {
          @{$ref_recvs} = $line =~ m/tuple2\("(\w+)", \d*\)/g;
	}
    }
    CORE::close(EXISTING);
}

sub need_to_regenerate_surrogate {

  my $filename = shift;
  my $log_file = shift;
  
  my @conns = parse_dangling_connections($log_file);
  
  #If these differ we need to regenerate.

  my (@sends_existing, @recvs_existing);

  CORE::open(EXISTING, "< $filename") || return 1;
  parse_existing_dangling_connections($filename, \@sends_existing, \@recvs_existing);

  my $differ = 0;

  foreach my $conn_r (@conns) {
      my $these_differ = 0;

      my $ctype = $conn_r->[0];
      my $cidx  = $conn_r->[1];
      my $cname = $conn_r->[2];
      
      if ($ctype eq "Send") 
      {
        return 1 unless defined($sends_existing[$cidx]);
        my $existing = $sends_existing[$cidx];
	#print "Testing if Send $cname [$cidx] is different from $existing.\n";
        $these_differ = $cname ne $existing;
      } 
      elsif ($ctype eq "Rec") 
      {
        return 1 unless defined($recvs_existing[$cidx]);
        my $existing = $recvs_existing[$cidx];
	#print "Testing if Recv $cname [$cidx] is different from $existing.\n";
        $these_differ = $cname ne $existing;
      } 
      else 
      {
	DIE("Unrecognized type of dangling connection: $ctype\n");
      }
      $differ = $differ || $these_differ;
  }

  return $differ;
}

sub get_provider {
    my $module = shift;
    my $metatype = shift;

    if ($module->provides() eq $metatype) {
	return $module;
    }

    # recurse
    foreach my $submodule ($module->submodules()) {
	my $result = get_provider($submodule,$metatype);
	if ($result != 0) {
	    return $result;
	}
    }

    return 0;
}


sub WARN {
    my $msg = shift;
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
    print STDERR "$filename: ($subroutine) [called from ln $line]: $msg\n";
}

sub DIE {
    my $msg = shift;
    WARN($msg);
    die;
}
