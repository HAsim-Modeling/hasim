: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

use strict;
use Getopt::Long;
use IO::File;
use POSIX qw(ceil floor);

my %defs;

# Debugging info
my $progName = 'hasim-dict';
my $line = 0;
my $fName = '';

# Options
my $help = 0;
my $queryModules = 0;
my $tgtHwDir = '';
my $tgtIncDir = '';

sub Error($) {
    my $msg = shift;
    print STDERR "${progName}: ${fName}:${line}, $msg\n";
    exit(1);
}

sub Usage($) {
    my $status = shift;

    print STDERR "Usage: $0 [--querymodules] [--tgt <dir>] <input files>\n";
    print STDERR "  Emit C or Bluespec data dictionaries derived from input files.\n\n";
    print STDERR "  --querymodules:  Just print the module names described in the input\n";
    print STDERR "                   files and exit.\n";
    print STDERR "  --tgt-inc <dir>: Target directory for include files.\n";
    print STDERR "  --tgt-hw  <dir>: Target directory for hw (BSV) files.\n";
    exit($status);
}


##
## EmitHeader --
##   Emit the common header of bsh and h files.
##
sub EmitHeader($) {
    my $of = shift;

    print $of "//\n";
    print $of "// *** DO NOT EDIT ***\n";
    print $of "//\n";
    print $of "// This file is generated by $progName\n";
    print $of "//\n\n";
}


##
## EmitH --
##   Emit one H file for specified module.
##
sub EmitH($) {
    my $m = shift;

    my $fn = "${tgtIncDir}${m}.h";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "#ifndef __DICT_${m}_H__\n";
    print $of "#define __DICT_${m}_H__\n\n";

    print $of "enum DICT_${m}_ENUM\n";
    print $of "{\n";
    my $idx = 0;
    foreach my $n (sort keys %{$defs{$m}}) {
        print $of "    ${m}_${n} = ${idx},\n";
        $idx += 1;
    }
    print $of "};\n\n";

    print $of "#define ${m}_last " . ($idx - 1) . "\n";

    my $bits = ceil(log($idx) / log(2));

    # Technically 0 bits would work if there is only a single dictionary entry.
    # One bit will probably make code happier.
    $bits = 1 if ($bits == 0);

    print $of "#define ${m}_bits ${bits}\n";

    print $of <<END;
class DICT_${m}
{
  private:
    static char * str[];

  public:
    DICT_${m}() {};
    ~DICT_${m}() {};

    static const char * Str(int i) { return str[i]; }
};

#endif //  __DICT_${m}_H__

#ifdef DICT_INIT
#ifndef __DICT_${m}_INIT__
#define __DICT_${m}_INIT__

END

    print $of "char *DICT_${m}::str[] =\n";
    print $of "{\n";
    foreach my $n (sort keys %{$defs{$m}}) {
        print $of "    $defs{$m}{$n},\n";
    }
    print $of "};\n\n";

    print $of "#endif // __DICT_${m}_INIT__\n";
    print $of "#endif // DICT_INIT\n";

    undef $of;
}


##
## EmitBSH --
##   Emit one BSH file for specified module.
##
sub EmitBSH($) {
    my $m = shift;

    my $fn = "${tgtIncDir}${m}.bsh";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "`ifndef INCLUDED_MODULE_DICT_${m}\n";
    print $of "`define INCLUDED_MODULE_DICT_${m}\n\n";

    print $of "import DICT_${m}::*;\n";

    print $of "\n`endif  // INCLUDED_MODULE_DICT_${m}\n";

    undef $of;
}


##
## EmitBSV --
##   Emit one BSH file for specified module.
##
sub EmitBSV($) {
    my $m = shift;

    my $fn = "${tgtHwDir}DICT_${m}.bsv";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "typedef enum\n";
    print $of "{\n";

    my $idx = 0;
    foreach my $n (sort keys %{$defs{$m}}) {
        if ($idx != 0) {
            print $of ",\n";
        }
        print $of "    ${n} = $idx";
        $idx += 1;
    }

    print $of "\n} DICT_${m} deriving (Bits, Eq, Bounded);\n";

    print $of "\n\n";

    print $of "function String showDICT_${m}(DICT_${m} inp);\n\n";
    print $of "    case (inp)\n";

    my $idx = 0;
    foreach my $n (sort keys %{$defs{$m}}) {
        print $of "        ${n}: return $defs{$m}{$n};\n";
        $idx += 1;
    }

    print $of "\n    endcase\n\n";

    print $of "\nendfunction\n";

    undef $of;
}


##
## EmitInit --
##   Emit one H file that defines all the strings.  Only one module in
##   a program should include this file.
##
sub EmitInit() {
    my $fn = "${tgtIncDir}init.h";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "#ifndef DICT_INIT\n";
    print $of "#define DICT_INIT\n";
    print $of "#endif\n\n";

    foreach my $m (sort keys %defs) {
        print $of "#include \"asim/dict/${m}.h\"\n";
    }

}


##
## AddDef --
##   Add a definition to the dictionary.
##
sub AddDef($$) {
    my $name = shift;
    my $value = shift;

    my @n = split(/\./, $name);
    if ($#n != 1) {
        Error("Illegal definition name");
    }

    if (exists($defs{$n[0]}{$n[1]})) {
        Error("Duplicate name ($name)");
    }

    $defs{$n[0]}{$n[1]} = $value;
}

##
## QuotedString --
##   Function holding the regular expression that matches a quoted string.
##   Escaped quotes are considered part of the string.
##
sub QuotedString($)
{
    my $type = quotemeta shift;
    return qr/
        $type
        (?:
            [^$type]+
            |
            (?<= \\ ) $type
        )*
        $type
    /x;
}

##
## ParseStdToken --
##   Parse a standard token from the argument string.  Return the token
##   and the remainder of the string.
##
sub ParseStdToken($) {
    my $text = shift;

    $text =~ s/^([A-Za-z0-9_\.]+)//;
    my $tok = defined($1) ? $1 : '';
    return ($tok, $text);
}


##
## ParseLine --
##   The core of the input parser's state machine.  Parse the next token
##   from the supplied line of text.
##
use enum qw(:PARSE_ CMD DEF_MODULE DEF_VALUE SEMICOLON);
my $parseState = PARSE_CMD;
my $defModule = '';

sub ParseLine($) {
    my $text = shift;
    my $tok = '';

    return '' if ($text eq '');

    if ($parseState == PARSE_CMD) {
        ($tok, $text) = ParseStdToken($text);
        if ($tok ne 'def') {
            Error("Illegal operator");
        }
        $parseState = PARSE_DEF_MODULE;
    }
    elsif ($parseState == PARSE_DEF_MODULE) {
        ($defModule, $text) = ParseStdToken($text);
        $parseState = PARSE_DEF_VALUE;
    }
    elsif ($parseState == PARSE_DEF_VALUE) {
        $text =~ s/ ((??{ QuotedString( qq(") ) })) //x;
        my $v = $1;
        if ($v eq '') {
            Error("Expected quoted string");
        }
        AddDef($defModule, $v);
        $parseState = PARSE_SEMICOLON;
    }
    elsif ($parseState == PARSE_SEMICOLON) {
        if (substr($text, 0, 1) ne ';') {
            Error("Expected semicolon");
        }
        $text = substr($text, 1);
        $parseState = PARSE_CMD;
    }
    else {
        Error("Illegal parse state");
    }

    return $text;
}

##
## ParseInputFile --
##   Read text from the input file and pass it to the parser.
##
sub ParseInputFile($) {
    $fName = shift;
    $line = 0;

    open(IF, $fName) or die("Failed to open $fName");

    while (<IF>) {
        chomp;
        my $d = $_;
        $line += 1;

        while ($d ne '') {
            ## Strip leading white space
            $d =~ s/^\s+//;

            ## Strip comments
            $d =~ s/^\/\/.*//;

            $d = ParseLine($d);
        }
    }

    close(IF);
}


##
## main --
##

if (! GetOptions(
          'help!'         => \$help,
          'querymodules!' => \$queryModules,
          'tgt-hw=s'      => \$tgtHwDir,
          'tgt-inc=s'     => \$tgtIncDir,
      )) {
    Usage(1);
}

Usage(0) if ($help);

foreach my $f (@ARGV) {
    ParseInputFile($f);
}

if ($tgtHwDir ne '') {
    if (! -d $tgtHwDir) {
        print STDERR "${progName}: Target directory ${tgtHwDir} doesn't exist\n";
        exit(1);
    }
    $tgtHwDir .= '/';
}

if ($tgtIncDir ne '') {
    if (! -d $tgtIncDir) {
        print STDERR "${progName}: Target directory ${tgtIncDir} doesn't exist\n";
        exit(1);
    }
    $tgtIncDir .= '/';
}

if ($queryModules) {
    ##
    ## Just print module names and exit
    ##
    foreach my $g (sort keys %defs) {
        print $g . "\n";
    }
    exit(0);
}

foreach my $g (sort keys %defs) {
    print "  Dictionary: $g\n";
    EmitBSV($g);
    EmitBSH($g);
    EmitH($g);
}

EmitInit();
