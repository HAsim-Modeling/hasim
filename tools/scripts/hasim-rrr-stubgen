: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  Angshuman Parashar
#

use warnings;
use strict;
use re 'eval';

use Getopt::Long;
use File::Basename;
use Data::Dumper;

$| = 1;

# parse command line
my $usage = "usage: hasim-rrr-stubgen\n" .
            "           -mode      (stub | names | debug)\n" .
            "           -target    (hw | sw)\n" .
            "           -type      (client | server)\n" .
            "           -odir <outputdir>\n" .
            "           INPUTFILE\n";

my $mode = "";
my $target = "";
my $type = "";
my $odir = "";

GetOptions("mode=s"      => \$mode,
           "target=s"    => \$target,
           "type=s"      => \$type,
           "odir=s"      => \$odir);

my @fNames;
my @sTables;
my @serviceTable;


##
## Start by parsing all the input files.  After parsing we'll have a few
## data structures:
##
##   @fNames -- an array of the names of input .rrr files
##   @sTables -- An array of the parsed RRR data from individual files
##   @serviceTable -- A merged array of sTables merged from all input files
##
my $idx = 0;
foreach my $ifile (@ARGV)
{
    my ($iname, $ipath, $isuffix) = fileparse($ifile, qr/\.[^.]*/);

    if ($isuffix ne '.rrr')
    {
        print "error: input filename $ifile must end with .rrr suffix\n";
        exit(1);
    }

    $fNames[$idx] = $iname;

    # parse input RRR file into data structure
    @{$sTables[$idx]} = parse_rrr_file($ifile);
    push (@serviceTable, @{$sTables[$idx]});

    $idx += 1;
}

##
## Canonicalize output directory specification
##
if ($odir ne "")
{
    # generate output file name from input file name
    if ($odir =~ /(\S+)\/+$/)
    {
        # get rid of trailing forward slashes
        $odir = $1;
    }
}
else
{
    $odir = ".";
}

##
## Process according to mode
##
if ($mode eq "stub")
{
    ##
    ## Generate individual stubs
    ##
    foreach my $idx (0..$#fNames)
    {
        # my $ofile = $odir . "/" . $fNames[$idx] . ".bsh";
        my $ofile = $odir . "/rrr_service_stub_" . get_service_name(@{$sTables[$idx]}) . ".bsh";
        open(my $ohandle, "> $ofile") || die "stubgen: unable to open output file $ofile";
        print_service_stub($ohandle, @{$sTables[$idx]});
        close($ohandle);
    }

    ##
    ## Generate connections
    ##
    my $ofile = $odir . "/rrr_service_connections.bsh";
    open(my $ohandle, "> $ofile") || die "stubgen: unable to open output file $ofile";
    print_service_connections($ohandle, @serviceTable);
    close($ohandle);

    ##
    ## Global service IDs
    ##
    open(my $ohandle_h, "> ${odir}/rrr_service_ids.h") ||
        die "stubgen: unable to open output file ${odir}/rrr_service_ids.h";
    open(my $ohandle_bsh, "> ${odir}/rrr_service_ids.bsh") ||
        die "stubgen: unable to open output file ${odir}/rrr_service_ids.bsh";
    print_service_ids($ohandle_h, $ohandle_bsh, @serviceTable);
}
elsif ($mode eq "names")
{
    print_service_names(\*STDOUT, @serviceTable);
}
elsif ($mode eq "debug")
{
    dump_service_table(\*STDOUT, @serviceTable);
}
else
{
    print $usage;
    exit(1);
}

exit(0);

############################################################
# get_service_name: given a parsed service table, return the
#                   name of the first service in the table
sub get_service_name
{
    my ($head, @tail) = @_;
    return $head->{name};
}

############################################################
# print_service_names: given a parsed service table, print
#                      out a list of service names
sub print_service_names
{
    my $ofile = shift;
    my @serviceTable = @_;

    foreach my $service (@serviceTable)
    {
        print $ofile $service->{name} . "\n";
    }
}


############################################################
# parse_rrr_file: parse an RRR file into a service table
sub parse_rrr_file
{
    my $filename = shift;

    CORE::open(RRRFILE, "< $filename") || die "stubgen: unable to open input file $filename";

    my $source = "";
    my $line;

    while (defined($line = <RRRFILE>))
    {
        chomp $line;

        # get rid of comments
        if ($line =~ /(.*?)\/\//)
        {
            $source .= $1;
        }
        else
        {
            $source .= $line;
        }
    }

    # characters
    my $p_character = qr/[\w_\.]/x;
    my $p_digit = qr/\d/x;

    # atomics
    my $p_string = qr/
                        \s*?
                        \"
                        \S+
                        \"
                        \s*?
                     /x;

    my $p_identifier = qr/
                            \s*?
                            $p_character+
                            \s*?
                         /x;

    my $p_type = qr/
                        \s*?
                        $p_character+
                        \s*?
                   /x;

    my $p_numeral = qr/
                        \s*?
                        $p_digit+
                        \s*?
                      /x;

    # compounds
    my $p_arg = qr/
                    (in|out)
                    \s+
                    ($p_type)
                    \s*?
                    \[
                    \s*?
                    ($p_numeral)
                    \s*?
                    \]
                    \s+
                    ($p_identifier)
                  /x;

    my $p_arglist = qr/ (
                            ($p_arg) |
                            (?:
                                ($p_arg)
                                ,
                                \s*?
                                (??{ $p_arglist })
                            )
                        )
                      /x;

    # atomic statements
    my $p_method = qr/
                        \s*?
                        method
                        \s+
                        ($p_identifier)
                        \s*?
                        \(
                        ($p_arglist)
                        \)
                        \s*?
                        ;
                        \s*?
                     /x;

    my $p_connection = qr/
                            \s*?
                            connection
                            \s+
                            ($p_identifier)
                            \s*?
                            \(
                            ($p_arglist)
                            \)
                            \s*?
                            ;
                            \s*?
                         /x;
    # statement
    my $p_statement = qr/($p_method | $p_connection)/x;

    # partition
    my $p_partition = qr/
                            \s*?
                            server
                            ($p_identifier)
                            \s*?
                            <-
                            ($p_identifier)
                            \{
                            \s*?    # careful, possibly ambiguous!
                            ($p_statement*)
                            \s*?    # careful, possibly ambiguous!
                            \}
                            \s*?
                            ;
                            \s*?
                        /x;
    
    # service
    my $p_service = qr/
                        \s*?
                        service
                        ($p_identifier)
                        \{
                        ($p_partition*)
                        \}
                        \s*?
                        ;
                        \s*?
                       /x;

    # next parse service defs
    my @serviceTable;
    while ($source =~ /$p_service/g)
    {
        # create a new RRR service class
        my %service;
        $service{name} = __trim($1);
        @{ $service{methods} } = ();
        @{ $service{connections} } = ();

        my $all_partitions = $2;
        while ($all_partitions =~ /$p_partition/g)
        {
            # only process hardware partition for now
            if (__trim($1) eq "hw")
            {
                my $clients = $2;           # ignore for now
                my $all_statements = $3;
                while ($all_statements =~ /$p_statement/g)
                {
                    my $s = $1;
                    if ($s =~ /$p_method/)
                    {
                        my $name = $1;
                        my $args = $2;

                        # create a new method
                        my %method;
                        $method{name} = __trim($name);

                        # pre-initialize type sizes
                        $method{insize} = 0;
                        $method{outsize} = 0;

                        # parse args and determine actual types
                        while ($args =~ /$p_arglist/g)
                        {
                            if ($1 =~ /$p_arg/)
                            {
                                my $argtype = __trim($1);
                                if ($argtype eq "in")
                                {
                                    $method{intype} = $2;
                                    $method{insize} = $3;
                                }
                                elsif ($argtype eq "out")
                                {
                                    $method{outtype} = $2;
                                    $method{outsize} = $3;
                                }
                            }
                        }

                        # push new method into service list
                        push(@{ $service{methods} }, { %method });
                    }
                    elsif ($s =~ /$p_connection/)
                    {
                        my $name = $1;
                        my $args = $2;

                        # create a new connection
                        my %connection;
                        $connection{name} = __trim($name);

                        # pre-initialize type sizes
                        $connection{insize} = 0;
                        $connection{outsize} = 0;

                        # parse args and determine actual types
                        while ($args =~ /$p_arglist/g)
                        {
                            if ($1 =~ /$p_arg/)
                            {
                                my $argtype = __trim($1);
                                if ($argtype eq "in")
                                {
                                    $connection{intype} = $2;
                                    $connection{insize} = $3;
                                }
                                elsif ($argtype eq "out")
                                {
                                    $connection{outtype} = $2;
                                    $connection{outsize} = $3;
                                }
                            }
                        }

                        # push new connection into service list
                        push(@{ $service{connections} }, { %connection });
                    }           
                }
            }
        }

        # push service into service table
        push(@serviceTable, { %service });
    }

    CORE::close(RRRFILE);

    return @serviceTable;
}

############################################################
# dump_service_table: dump a service table in human-readable
#                     format to given file handle
sub dump_service_table
{
    my $ofile = shift;
    my @serviceTable = @_;

    foreach my $service (@serviceTable)
    {
        my $servicename = $service->{name};
        print $ofile "service name: $servicename\n";
        print $ofile "\n";

        my @methodlist  = @{ $service->{methods} };
        foreach my $method (@methodlist)
        {
            my $methodName      = $method->{name};
            print $ofile "    method name: $methodName\n";
            if ($method->{insize} == 0)
            {
                print $ofile "        in : void\n";
            }
            else
            {
                print $ofile "        in : $method->{intype}\[$method->{insize}\]\n";
            }
            if ($method->{outsize} == 0)
            {
                print $ofile "        out: void\n";
            }
            else
            {
                print $ofile "        out: $method->{outtype}\[$method->{outsize}\]\n";
            }
            print $ofile "\n";
        }

        my @connectionlist  = @{ $service->{connections} };
        foreach my $connection (@connectionlist)
        {
            my $connectionname      = $connection->{name};
            print $ofile "    connection name: $connectionname\n";
            if ($connection->{insize} == 0)
            {
                print $ofile "        in : void\n";
            }
            else
            {
                print $ofile "        in : $connection->{intype}\[$connection->{insize}\]\n";
            }
            if ($connection->{outsize} == 0)
            {
                print $ofile "        out: void\n";
            }
            else
            {
                print $ofile "        out: $connection->{outtype}\[$connection->{outsize}\]\n";
            }
            print $ofile "\n";
        }
    }
}

############################################################
# __trim: remove whitespaces from a string
sub __trim
{
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

############################################################
# print_service_ids: given a parsed service table, print
#                    service id include files for C++ and BSC
sub print_service_ids
{
    my $ofile_h = shift;
    my $ofile_bsh = shift;
    my @serviceTable = @_;

    print_std_header($ofile_h);
    print $ofile_h "\#ifndef __RRR_SERVICE_IDS__\n";
    print $ofile_h "\#define __RRR_SERVICE_IDS__\n";
    print $ofile_h "\n";

    print_std_header($ofile_bsh);
    print $ofile_bsh "\`ifndef __RRR_SERVICE_IDS__\n";
    print $ofile_bsh "\`define __RRR_SERVICE_IDS__\n";
    print $ofile_bsh "\n";

    my $serviceID = 0;
    foreach my $service (@serviceTable)
    {
        print $ofile_h   "\#define " . $service->{name} . "_SERVICE_ID $serviceID\n";
        print $ofile_bsh "\`define " . $service->{name} . "_SERVICE_ID $serviceID\n";
        $serviceID = $serviceID + 1;
    }

    print $ofile_h "\#define NUM_SERVICES $serviceID\n";
    print $ofile_h "\n";
    print $ofile_h "\#endif // __RRR_SERVICE_IDS__\n";

    print $ofile_bsh "\`define NUM_SERVICES $serviceID\n";
    print $ofile_bsh "\n";
    print $ofile_bsh "\`endif // __RRR_SERVICE_IDS__\n";
}


############################################################
# print_std_header: Print a standard header
#
sub print_std_header
{
    my $ofile = shift;

    print $ofile "//\n";
    print $ofile "// Synthesized header file created by hasim-rrr-stubgen\n";
    print $ofile "//\n\n";
}

############################################################
# print_service_connections: given a parsed service table,
#                            print out a wrapper module that
#                            (a) instantiates a stub module
#                                for each service, and
#                            (b) creates connection
#                                interfaces to each stub
#                                module
sub print_service_connections
{
    my $stubfile = shift;
    my @serviceTable = @_;

    print_std_header($stubfile);

    # generate common header
    print $stubfile "`ifndef _RRR_SERVICE_CONNECTIONS_\n";
    print $stubfile "`define _RRR_SERVICE_CONNECTIONS_\n";
    print $stubfile "\n";

    print_std_header($stubfile);

    print $stubfile "`include \"soft_connections.bsh\"\n";
    print $stubfile "`include \"rrr.bsh\"\n";
    print $stubfile "`include \"channelio.bsh\"\n";
    print $stubfile "`include \"umf.bsh\"\n";
    print $stubfile "`include \"asim/rrr/rrr_service_ids.bsh\"\n";
    print $stubfile "\n";

    # import header files for generated stubs
    foreach my $service (@serviceTable)
    {
        my $servicename = $service->{name};
        my @connectionlist  = @{ $service->{connections} };

        if (@connectionlist)
        {
            print $stubfile "`include \"asim/rrr/rrr_service_stub_$servicename.bsh\"\n";
        }
    }
    print $stubfile "\n";

    # main module definition
    print $stubfile "module [HASim_Module] mkServiceConnections#(RRR_SERVER server) ();\n";
    print $stubfile "\n";

    # for each service
    foreach my $service (@serviceTable)
    {
        my $servicename = $service->{name};
        my @connectionlist  = @{ $service->{connections} };

        if (@connectionlist)
        {
            # instantiate stub module
            print $stubfile "    let stub_$servicename <- mkServiceStub_$servicename(server);\n";
            print $stubfile "\n";
        }

        # per-connection state elements
        foreach my $connection (@connectionlist)
        {
            print_connection_instantiation($stubfile, $servicename, $connection);
        }

        print $stubfile "\n";
    }

    # again, for each service
    foreach my $service (@serviceTable)
    {
        my $servicename = $service->{name};
        my @connectionlist  = @{ $service->{connections} };

        # create a rule for each method in the service, binding it to a connection
        foreach my $connection (@connectionlist)
        {
            print_wrapper_rules($stubfile, $servicename, $connection);
        }
    }

    # end module
    print $stubfile "endmodule\n";
    print $stubfile "\n";

    # end stub file
    print $stubfile "`endif\n";
    print $stubfile "\n";
}

################################################################
# print_connection_instantiation: instantiate a connection
#
sub print_connection_instantiation
{
    my $stubfile = shift;
    my $servicename = shift;
    my $connection = shift;

    my $connectionname = $connection->{name};
    my $insize     = $connection->{insize};
    my $intype     = $connection->{intype};
    my $outsize    = $connection->{outsize};
    my $outtype    = $connection->{outtype};
    
    # print connection definitions
    if ($outsize == 0)
    {
        # void return type: create Send-type connection
        print $stubfile "    Connection_Send#($intype) link_$servicename" . "_$connectionname <- mkConnection_Send(\"rrr_service_$servicename\_$connectionname\");\n";
    }
    else
    {
        # non-void return type: create Client-type connection
        print $stubfile "    Connection_Client#($intype, $outtype) link_$servicename" . "_$connectionname <- mkConnection_Client(\"rrr_service_$servicename\_$connectionname\");\n";
    }
}

################################################################
# print_wrapper_rules: given a service connection, print wrapper
#                      rules that bind service methods to one
#                      end of the connection
sub print_wrapper_rules
{
    my $stubfile = shift;
    my $servicename = shift;
    my $connection = shift;

    my $connectionname = $connection->{name};
    my $insize     = $connection->{insize};
    my $intype     = $connection->{intype};
    my $outsize    = $connection->{outsize};
    my $outtype    = $connection->{outtype};
    
    # print rules to transfer request and response to the connection
    if ($outsize == 0)
    {
        # void return type: create only request rule, use send()
        print $stubfile "    rule acceptRequest_$servicename\_$connectionname (True);\n";
        print $stubfile "        $intype req <- stub_$servicename.acceptRequest\_$connectionname();\n";
        print $stubfile "        link_$servicename\_$connectionname.send(req);\n";
        print $stubfile "    endrule\n";
        print $stubfile "\n";
    }
    else
    {
        # non-void return type: create request and response rules, use makeReq()
        print $stubfile "    rule acceptRequest_$servicename\_$connectionname (True);\n";
        print $stubfile "        $intype req <- stub_$servicename.acceptRequest\_$connectionname();\n";
        print $stubfile "        link_$servicename\_$connectionname.makeReq(req);\n";
        print $stubfile "    endrule\n";
        print $stubfile "\n";
        
        print $stubfile "    rule sendResponse_$servicename\_$connectionname (True);\n";
        print $stubfile "        $outtype resp = link_$servicename\_$connectionname.getResp();\n";
        print $stubfile "        link_$servicename\_$connectionname.deq();\n";
        print $stubfile "        stub_$servicename.sendResponse\_$connectionname(resp);\n";
        print $stubfile "    endrule\n";
        print $stubfile "\n";
    }
}

################################################################
# print_service_stub: given a parsed service table, print out
#                     a full service stub
sub print_service_stub
{
    my $stubfile = shift;
    my @serviceTable = @_;

    print_std_header($stubfile);

    # determine if we should write stub at all
    my $do_write = 0;
    if (@serviceTable)
    {
        my ($service, @tail) = @serviceTable;

        # get list of regular methods
        my @regmethodlist  = @{ $service->{methods} };

        # get list of connection-based methods
        my @connectionlist = @{ $service->{connections} };

        # append both lists
        my @methodlist = (@regmethodlist, @connectionlist);

        if (@methodlist)
        {
            $do_write = 1;
        }
    }

    if ($do_write == 0)
    {
        return;
    }

    # generate header by looking at the name of the first service
    # TODO: change semantics such that only one service can be defined
    # per RRR file
    my ($first, @tail) = @serviceTable;
    my $name = $first->{name};
    print $stubfile "`ifndef _" . $name . "_SERVICE_STUB_\n";
    print $stubfile "`define _" . $name . "_SERVICE_STUB_\n";
    print $stubfile "\n";

    print $stubfile "//\n";
    print $stubfile "// Synthesized service stub file\n";
    print $stubfile "//\n";
    print $stubfile "\n";

    print $stubfile "`include \"rrr.bsh\"\n";
    print $stubfile "`include \"channelio.bsh\"\n";
    print $stubfile "`include \"umf.bsh\"\n";
    print $stubfile "\n";

    # create a module for each service
    foreach my $service (@serviceTable)
    {
        my $servicename = $service->{name};
        my @regmethodlist  = @{ $service->{methods} };
        my @connectionlist  = @{ $service->{connections} };

        my @methodlist = (@regmethodlist, @connectionlist);

        print_service_module($stubfile, $servicename, @methodlist);
    }

    # close stub file
    print $stubfile "`endif\n";
    print $stubfile "\n";
}

##############################################################
# print_service_module: given a list of method definitions for
#                       a service, print out a stub interface
#                       and module
sub print_service_module
{
    my $stubfile = shift;
    my $servicename = shift;
    my @methodlist = @_;

    # compute max request and response bitwidths
    my $maxinsize = 0;
    my $maxoutsize = 0;
    foreach my $method (@methodlist)
    {
        my $insize  = $method->{insize};
        my $outsize = $method->{outsize};
        
        if ($insize > $maxinsize)
        {
            $maxinsize = $insize;
        }
        
        if ($outsize > $maxoutsize)
        {
            $maxoutsize = $outsize;
        }
    }

    # helper definition for service ID
    print $stubfile "`define SERVICE_ID `$servicename\_SERVICE_ID\n";
    print $stubfile "\n";

    # interface ...
    print $stubfile "interface ServiceStub_$servicename;\n";
    
    # interface entry for each method
    foreach my $method (@methodlist)
    {
        print_method_declarations($stubfile, $method);
    }
    
    # endinterface
    print $stubfile "endinterface\n";
    print $stubfile "\n";
    
    # module mk...
    print $stubfile "module mkServiceStub_$servicename#(RRR_SERVER server) (ServiceStub_$servicename);\n";
    print $stubfile "\n";
    
    # module state
    print_module_state($stubfile, $maxinsize, $maxoutsize);
    
    # per-method state and definitions
    print_method_state_all($stubfile, @methodlist);

    # global (i.e., not RRR-method-specific) rules
    print_module_rules_request($stubfile);
    if ($maxoutsize != 0)
    {
        print_module_rules_response($stubfile);
    }

    # method definitions
    foreach my $method (@methodlist)
    {
        print_method_definitions($stubfile, $servicename, $maxinsize, $maxoutsize, $method);
    }
    
    # endmodule
    print $stubfile "endmodule\n";
    print $stubfile "\n";
}

##############################################################
# print_method_declarations: print request and response method
#                            declarations for interface
sub print_method_declarations
{
    my $stubfile = shift;
    my $method   = shift;

    my $methodname = $method->{name};
    my $insize     = $method->{insize};
    my $intype     = $method->{intype};
    my $outsize    = $method->{outsize};
    my $outtype    = $method->{outtype};

    # request
    print $stubfile "    method ActionValue#($intype) acceptRequest_$methodname();\n";

    # response
    if ($outsize != 0)
    {
        print $stubfile "    method Action sendResponse_$methodname($outtype resp);\n";
    }
}

##############################################################
# print_module_state: print global module state
sub print_module_state
{
    my $stubfile   = shift;
    my $maxinsize  = shift;
    my $maxoutsize = shift;

    print $stubfile "    DEMARSHALLER#(UMF_CHUNK, Bit#($maxinsize)) dem <- mkDeMarshaller();\n";
    print $stubfile "    Reg#(UMF_METHOD_ID) mid <- mkReg(0);\n";
    print $stubfile "\n";
    if ($maxoutsize != 0)
    {
        print $stubfile "    MARSHALLER#(Bit#($maxoutsize), UMF_CHUNK) mar <- mkMarshaller();\n";
        print $stubfile "\n";
    }
}

##############################################################
# print_module_rules_request: print global request rules for a
#                             service module
sub print_module_rules_request
{
    my $stubfile = shift;

    print $stubfile "    rule startRequest (True);\n";
    print $stubfile "        UMF_PACKET packet <- server.requestPorts[`SERVICE_ID].read();\n";
    print $stubfile "        mid <= packet.UMF_PACKET_header.methodID;\n";
    print $stubfile "        dem.start(packet.UMF_PACKET_header.numChunks);\n";
    print $stubfile "    endrule\n";
    print $stubfile "\n";
    
    print $stubfile "    rule continueRequest (True);\n";
    print $stubfile "        UMF_PACKET packet <- server.requestPorts[`SERVICE_ID].read();\n";
    print $stubfile "        dem.insert(packet.UMF_PACKET_dataChunk);\n";
    print $stubfile "    endrule\n";
    print $stubfile "\n";
}

##############################################################
# print_module_rules_response: print global response rules for
#                              a service module
sub print_module_rules_response
{
    my $stubfile = shift;
    my $servicename = shift;

    print $stubfile "    rule continueResponse (True);\n";
    print $stubfile "        UMF_CHUNK chunk = mar.first();\n";
    print $stubfile "        mar.deq();\n";
    print $stubfile "        server.responsePorts[`SERVICE_ID].write(tagged UMF_PACKET_dataChunk chunk);\n";
    print $stubfile "    endrule\n";
    print $stubfile "\n";
}

##############################################################
# print_method_state_all: print per-method local state and
#                         definitions for all methods
sub print_method_state_all
{
    my $stubfile = shift;
    my @methodlist = @_;

    my $methodID = 0;
    foreach my $method (@methodlist)
    {
        my $methodname = $method->{name};
        my $outsize    = $method->{outsize};

        print $stubfile "    Integer mid_$methodname = $methodID;\n";
        $methodID = $methodID + 1;

        if ($outsize != 0)
        {
            print $stubfile "    Integer numChunks_$methodname = ($outsize % `UMF_CHUNK_BITS) == 0 ?\n";
            print $stubfile "        ($outsize / `UMF_CHUNK_BITS) :\n";
            print $stubfile "        ($outsize / `UMF_CHUNK_BITS) + 1;\n";
        }
    }
    print $stubfile "\n";    
}

##############################################################
# print_method_definitions: print request and response method
#                           definitions for a particulat RRR
#                           service method
sub print_method_definitions
{
    my $stubfile    = shift;
    my $servicename = shift;
    my $maxinsize   = shift;
    my $maxoutsize  = shift;
    my $method      = shift;

    my $methodname = $method->{name};
    my $insize     = $method->{insize};
    my $intype     = $method->{intype};
    my $outsize    = $method->{outsize};
    my $outtype    = $method->{outtype};

    # print REQUEST method definition
    print $stubfile "    method ActionValue#($intype) acceptRequest_$methodname() if (mid == fromInteger(mid_$methodname));\n";
    print $stubfile "        Bit#($maxinsize) a <- dem.readAndDelete();\n";
    
    # if insize is smaller than maxinsize, then we need to truncate
    if ($insize < $maxinsize)
    {
        print $stubfile "        $intype retval = truncate(unpack(a));\n";
    }
    else
    {
        print $stubfile "        $intype retval = unpack(a);\n";
    }
    print $stubfile "        return retval;\n";
    print $stubfile "    endmethod\n";
    print $stubfile "\n";
    
    # print RESPONSE method definition
    if ($outsize != 0)
    {
        print $stubfile "    method Action sendResponse_$methodname($outtype resp) if (True);\n";
        print $stubfile "        UMF_PACKET header = tagged UMF_PACKET_header\n";
        print $stubfile "                            {\n";
        print $stubfile "                                channelID: ?,\n";
        print $stubfile "                                serviceID: `SERVICE_ID,\n";
        print $stubfile "                                methodID : fromInteger(mid_$methodname),\n";
        print $stubfile "                                numChunks: fromInteger(numChunks_$methodname)\n";
        print $stubfile "                            };\n";
        print $stubfile "        server.responsePorts[`SERVICE_ID].write(header);\n";
        print $stubfile "        mar.enq(resp);\n";
        print $stubfile "    endmethod\n";
        print $stubfile "\n";
    }
}
