: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  Angshuman Parashar
#

use warnings;
use strict;
use re 'eval';

use Getopt::Long;

# parse command line
my $usage = "usage: hasim-rrr-stubgen -mode=generate-stub -odir=OUTPUTDIR INPUTFILE\n" .
            "       hasim-rrr-stubgen -mode=print-service-names INPUTFILE\n" .
            "       hasim-rrr-stubgen -mode=dump-service-table  INPUTFILE\n";

my $mode = "";
my $odir = "";

GetOptions("mode=s" => \$mode, "odir=s" => \$odir);
my $ifile = $ARGV[0];

# check command line
if ($mode eq ""                         ||
    ($mode ne "print-service-names"  &&
        $mode ne "generate-stub" &&
        $mode ne "dump-service-table")  ||
    ($mode eq "generate-stub"    &&
        $odir eq ""))
{
    print $usage;
    exit;
}

my $iprefix;
if ($ifile =~ /\S+\/(\S+)\.rrr/)
{
    $iprefix = $1;
}
else
{
    print "error: input filename must end with .rrr suffix\n";
    exit;
}

# parse input RRR file into data structure
# note: to read in multiple RRR files, call this subroutine
# multiple times and append returned list to @serviceTable
my @serviceTable = parse_rrr_file($ifile);

# find out what to print
if ($mode eq "print-service-names")
{
    print_service_names(@serviceTable);
}
elsif ($mode eq "generate-stub")
{
    # generate output file name from input file name
    if ($odir =~ /(\S+)\/+$/)
    {
        # get rid of trailing forward slashes
        $odir = $1;
    }
    my $ofile = $odir . "/" . $iprefix . ".bsh";
    print_service_stub($ofile, @serviceTable);
}
elsif ($mode eq "dump-service-table")
{
    dump_service_table(@serviceTable);
}

############################################################
# print_service_names: given a parsed service table, print
#                      out a list of service names
sub print_service_names {

    my @serviceTable = @_;

    foreach my $service (@serviceTable)
    {
        print $service->{name} . "\n";
    }
}

############################################################
# print_rrr_stub: given a parsed service table, print out
#                 an RRR service stub
sub print_service_stub {

    my $stubfile = shift;
    my @serviceTable = @_;

    # make RRR stub files
    # only open file if we have at least one service
    if (@serviceTable)
    {
        CORE::open(STUBFILE, ">$stubfile") or die "unable to open $stubfile\n";

        # generate header by looking at the name of the first service
        # TODO: change semantics such that only one service can be defined
        # per RRR file
        my ($first, @tail) = @serviceTable;
        my $name = $first->{name};
        print STUBFILE "`ifndef _" . $name . "_SERVICE_STUB_\n";
        print STUBFILE "`define _" . $name . "_SERVICE_STUB_\n";
        print STUBFILE "\n";

        print STUBFILE "//\n";
        print STUBFILE "// Synthesized service stub file\n";
        print STUBFILE "//\n";
        print STUBFILE "\n";

        print STUBFILE "`include \"rrr.bsh\"\n";
        print STUBFILE "`include \"rrr_service_ids.bsh\"\n";
        print STUBFILE "\n";

        print STUBFILE "typedef enum\n";
        print STUBFILE "{\n";
        print STUBFILE "    STUB_STATE_idle,\n";
        print STUBFILE "    STUB_STATE_processing,\n";
        print STUBFILE "    STUB_STATE_awaitingResponse\n";
        print STUBFILE "}\n";
        print STUBFILE "STUB_STATE\n";
        print STUBFILE "    deriving (Bits, Eq);\n";
        print STUBFILE "\n";
    }

    # create an interface for each service
    foreach my $service (@serviceTable)
    {
        my $serviceName = $service->{name};
        my @methodlist  = @{ $service->{methods} };

        # first assign methodIDs
        # also figure out maximum parameter bitwidth
        my $methodID = 0;
        my $maxinsize = 0;
        foreach my $method (@methodlist)
        {
            my $methodname = $method->{name};
            my $insize     = $$method{insize};
            my $intype     = $method->{intype};
            my $outsize    = $method->{outsize};
            my $outtype    = $method->{outtype};

            # method ID
            print STUBFILE "`define " . $methodname . "_METHOD_ID " . $methodID . "\n";
            $methodID = $methodID + 1;

            # max param size
            if ($insize > $maxinsize)
            {
                $maxinsize = $insize;
            }
        }
        print STUBFILE "\n";

        # service interface
        print STUBFILE "interface ServiceStub_$serviceName;\n";

        # interface entry for each method
        foreach my $method (@methodlist)
        {
            my $methodname = $method->{name};
            my $insize     = $$method{insize};
            my $intype     = $method->{intype};
            my $outsize    = $method->{outsize};
            my $outtype    = $method->{outtype};

            if ($insize != 0)
            {
                print STUBFILE "    method ActionValue#($intype) acceptRequest_$methodname();\n";
            }
            else
            {
                print STUBFILE "    method Action acceptRequest_$methodname();\n";
            }

            if ($outsize != 0)
            {
                print STUBFILE "    method Action sendResponse_$methodname($outtype);\n";
            }
        }
        print STUBFILE "endinterface\n";
        print STUBFILE "\n";

        print STUBFILE "module mkServiceStub_$serviceName#(RRRServer server) (ServiceStub_$serviceName);\n";
        print STUBFILE "\n";

        print STUBFILE "    DeMarshaller#(`UMF_CHUNK_BITS, $maxinsize)\n";
        print STUBFILE "                        dem   <- mkDeMarshaller();\n";
        print STUBFILE "    Reg#(UMF_METHOD_ID) mid   <- mkReg(0);\n";
        print STUBFILE "    Reg#(STUB_STATE)    state <- mkReg(STUB_STATE_idle);\n";
        print STUBFILE "\n";

        # universal rules
        print STUBFILE "    rule probe_server_for_header (state == STUB_STATE_idle);\n";
        print STUBFILE "        UMF_PACKET packet <- server.read(`" . $serviceName . "_SERVICE_ID);\n";
        print STUBFILE "        mid <= packet.UMF_PACKET_header.methodID;\n";
        print STUBFILE "        state <= STUB_STATE_processing;\n";
        print STUBFILE "    endrule\n";
        print STUBFILE "\n";

        print STUBFILE "    rule probe_dispatcher_for_chunks (state == STUB_STATE_processing);\n";
        print STUBFILE "        UMF_PACKET packet <- server.read(`" . $serviceName . "_SERVICE_ID);\n";
        print STUBFILE "        dem.enq(pack(packet.UMF_PACKET_dataChunk));\n";
        print STUBFILE "    endrule\n";
        print STUBFILE "\n";

        # write methods
        foreach my $method (@methodlist)
        {
            my $methodname = $method->{name};
            my $insize     = $method->{insize};
            my $intype     = $method->{intype};
            my $outsize    = $method->{outsize};
            my $outtype    = $method->{outtype};

            if ($insize != 0)
            {
                print STUBFILE "    method ActionValue#($intype) acceptRequest_$methodname() if (mid == `" . $methodname . "_METHOD_ID);\n";
                print STUBFILE "        Bit#($maxinsize) a <- dem.deq();\n";
                print STUBFILE "        MEM_Addr retval = unpack(a);\n";
                print STUBFILE "        state <= STUB_STATE_idle;\n";
                print STUBFILE "        return retval;\n";
                print STUBFILE "    endmethod\n";
            }
            else
            {
                print STUBFILE "    method Action acceptRequest_$methodname() if (mid == `" . $methodname . "_METHOD_ID);\n";
                print STUBFILE "        noAction;\n";
                print STUBFILE "        ERROR: NOT SUPPORTED. WRITING JUNK BLUESPEC TO HALT COMPILER\n";
                print STUBFILE "    endmethod\n";
            }
            print STUBFILE "\n";

            if ($outsize != 0)
            {
                print STUBFILE "    method Action sendResponse_$methodname() if (state == STUB_STATE_awaitingResponse);\n";
                print STUBFILE "        noAction;\n";
                print STUBFILE "        ERROR: NOT SUPPORTED. WRITING JUNK BLUESPEC TO HALT COMPILER\n";
                print STUBFILE "    endmethod\n";
            }
        }

        print STUBFILE "endmodule\n";
        print STUBFILE "\n";
    }

    # close stub file
    if (@serviceTable)
    {
        print STUBFILE "`endif\n";
        print STUBFILE "\n";

        CORE::close(STUBFILE);
    }
}

############################################################
# parse_rrr_file: parse an RRR file into a service table
sub parse_rrr_file {

    my $filename = shift;

    CORE::open(RRRFILE, "< $filename");

    my $source = "";
    my $line;

    while (defined($line = <RRRFILE>))
    {
        chomp $line;

        # get rid of comments
        if ($line =~ /(.*?)\/\//)
        {
            $source .= $1;
        }
        else
        {
            $source .= $line;
        }
    }

    # characters
    my $p_character = qr/[\w_\.]/x;
    my $p_digit = qr/\d/x;

    # atomics
    my $p_string = qr/
                        \s*?
                        \"
                        \S+
                        \"
                        \s*?
                     /x;

    my $p_identifier = qr/
                            \s*?
                            $p_character+
                            \s*?
                         /x;

    my $p_type = qr/
                        \s*?
                        $p_character+
                        \s*?
                   /x;

    my $p_numeral = qr/
                        \s*?
                        $p_digit+
                        \s*?
                      /x;

    # compounds
    my $p_arg = qr/
                    (in|out)
                    \s+
                    ($p_type)
                    \s*?
                    \[
                    \s*?
                    ($p_numeral)
                    \s*?
                    \]
                    \s+
                    ($p_identifier)
                  /x;

    my $p_arglist = qr/ (
                            ($p_arg) |
                            (?:
                                ($p_arg)
                                ,
                                (??{ $p_arglist })
                            )
                        )
                      /x;

    # atomic statements
    my $p_method = qr/
                        \s*?
                        method
                        \s+
                        ($p_identifier)
                        \s*?
                        \(
                        ($p_arglist)
                        \)
                        \s*?
                        ;
                        \s*?
                     /x;

    # statement
    my $p_statement = qr/($p_method)/x;

    # partition
    my $p_partition = qr/
                            \s*?
                            server
                            ($p_identifier)
                            \s*?
                            <-
                            ($p_identifier)
                            \{
                            \s*?    # careful, possibly ambiguous!
                            ($p_statement*)
                            \s*?    # careful, possibly ambiguous!
                            \}
                            \s*?
                            ;
                            \s*?
                        /x;
    
    # service
    my $p_service = qr/
                        \s*?
                        service
                        ($p_identifier)
                        \{
                        ($p_partition*)
                        \}
                        \s*?
                        ;
                        \s*?
                       /x;

    # next parse service defs
    my @serviceTable;
    while ($source =~ /$p_service/g)
    {
        # create a new RRR service class
        my %service;
        $service{name} = __trim($1);
        @{ $service{methods} } = ();

        my $all_partitions = $2;
        while ($all_partitions =~ /$p_partition/g)
        {
            # only process hardware partition for now
            if (__trim($1) eq "hw")
            {
                my $clients = $2;           # ignore for now
                my $all_statements = $3;
                while ($all_statements =~ /$p_statement/g)
                {
                    my $s = $1;
                    if ($s =~ /$p_method/)
                    {
                        my $name = $1;
                        my $args = $2;

                        # create a new method
                        my %method;
                        $method{name} = __trim($name);

                        # pre-initialize type sizes
                        $method{insize} = 0;
                        $method{outsize} = 0;

                        # parse args and determine actual types
                        while ($args =~ /$p_arglist/g)
                        {
                            if ($1 =~ /$p_arg/)
                            {
                                my $argtype = __trim($1);
                                if ($argtype eq "in")
                                {
                                    $method{intype} = $2;
                                    $method{insize} = $3;
                                }
                                elsif ($argtype eq "out")
                                {
                                    $method{outtype} = $2;
                                    $method{outsize} = $3;
                                }
                            }
                        }

                        # push new method into service list
                        push(@{ $service{methods} }, { %method });
                    }
                }
            }
        }

        # push service into service table
        push(@serviceTable, { %service });
    }

    return @serviceTable;
}

############################################################
# dump_service_table: dump a service table in human-readable
#                     format to STDOUT
sub dump_service_table {

    my @serviceTable = @_;

    foreach my $service (@serviceTable)
    {
        my $serviceName = $service->{name};
        print "service name: $serviceName\n";
        print "\n";

        my @methodlist  = @{ $service->{methods} };
        foreach my $method (@methodlist)
        {
            my $methodName      = $method->{name};
            print "    method name: $methodName\n";
            if ($method->{insize} == 0)
            {
                print "        in : void\n";
            }
            else
            {
                print "        in : $method->{intype}\[$method->{insize}\]\n";
            }
            if ($method->{outsize} == 0)
            {
                print "        out: void\n";
            }
            else
            {
                print "        out: $method->{outtype}\[$method->{outsize}\]\n";
            }
            print "\n";
        }
    }
}

############################################################
# __trim: remove whitespaces from a string
sub __trim {

    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}
